<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>52hertz</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-11-12T06:01:58.058Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>52hertz</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>字符串匹配</title>
    <link href="http://yoursite.com/2019/11/12/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/"/>
    <id>http://yoursite.com/2019/11/12/字符串匹配/</id>
    <published>2019-11-12T06:01:58.000Z</published>
    <updated>2019-11-12T06:01:58.058Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>线段树</title>
    <link href="http://yoursite.com/2019/11/12/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    <id>http://yoursite.com/2019/11/12/线段树/</id>
    <published>2019-11-12T06:01:46.000Z</published>
    <updated>2019-11-12T06:01:46.511Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>数论</title>
    <link href="http://yoursite.com/2019/11/12/%E6%95%B0%E8%AE%BA/"/>
    <id>http://yoursite.com/2019/11/12/数论/</id>
    <published>2019-11-12T06:00:26.000Z</published>
    <updated>2019-11-12T06:00:26.654Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>拓扑排序</title>
    <link href="http://yoursite.com/2019/11/12/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2019/11/12/拓扑排序/</id>
    <published>2019-11-12T06:00:13.000Z</published>
    <updated>2019-11-12T06:00:13.893Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>并查集</title>
    <link href="http://yoursite.com/2019/11/12/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <id>http://yoursite.com/2019/11/12/并查集/</id>
    <published>2019-11-12T05:58:56.000Z</published>
    <updated>2019-11-12T05:58:56.416Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>单源最短路径问题</title>
    <link href="http://yoursite.com/2019/11/12/%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2019/11/12/单源最短路径问题/</id>
    <published>2019-11-12T05:58:37.000Z</published>
    <updated>2019-11-12T05:58:37.936Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>最小生成树</title>
    <link href="http://yoursite.com/2019/11/12/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
    <id>http://yoursite.com/2019/11/12/最小生成树/</id>
    <published>2019-11-12T05:58:10.000Z</published>
    <updated>2019-11-12T05:58:10.413Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>优先队列</title>
    <link href="http://yoursite.com/2019/11/12/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"/>
    <id>http://yoursite.com/2019/11/12/优先队列/</id>
    <published>2019-11-12T05:57:53.000Z</published>
    <updated>2019-11-12T05:57:53.580Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>二叉搜索树</title>
    <link href="http://yoursite.com/2019/11/12/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    <id>http://yoursite.com/2019/11/12/二叉搜索树/</id>
    <published>2019-11-12T05:57:40.000Z</published>
    <updated>2019-11-12T05:57:40.049Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>DFS+BFS</title>
    <link href="http://yoursite.com/2019/11/12/DFS-BFS/"/>
    <id>http://yoursite.com/2019/11/12/DFS-BFS/</id>
    <published>2019-11-12T05:57:00.000Z</published>
    <updated>2019-11-12T05:57:00.527Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>图</title>
    <link href="http://yoursite.com/2019/11/12/%E5%9B%BE/"/>
    <id>http://yoursite.com/2019/11/12/图/</id>
    <published>2019-11-12T05:56:29.000Z</published>
    <updated>2019-11-12T05:56:29.032Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>树</title>
    <link href="http://yoursite.com/2019/11/12/%E6%A0%91/"/>
    <id>http://yoursite.com/2019/11/12/树/</id>
    <published>2019-11-12T05:54:31.000Z</published>
    <updated>2019-11-12T05:54:31.183Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>动态规划DP</title>
    <link href="http://yoursite.com/2019/11/12/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92DP/"/>
    <id>http://yoursite.com/2019/11/12/动态规划DP/</id>
    <published>2019-11-12T05:54:09.000Z</published>
    <updated>2019-11-12T05:54:09.877Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>二分搜索，哈希</title>
    <link href="http://yoursite.com/2019/11/12/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%EF%BC%8C%E5%93%88%E5%B8%8C/"/>
    <id>http://yoursite.com/2019/11/12/二分搜索，哈希/</id>
    <published>2019-11-12T05:53:25.000Z</published>
    <updated>2019-11-12T05:53:25.636Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>c++ STL库函数</title>
    <link href="http://yoursite.com/2019/11/12/c-STL%E5%BA%93%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2019/11/12/c-STL库函数/</id>
    <published>2019-11-12T05:52:30.000Z</published>
    <updated>2019-11-12T05:52:30.223Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>递归和分治法</title>
    <link href="http://yoursite.com/2019/11/12/%E9%80%92%E5%BD%92%E5%92%8C%E5%88%86%E6%B2%BB%E6%B3%95/"/>
    <id>http://yoursite.com/2019/11/12/递归和分治法/</id>
    <published>2019-11-12T05:49:07.000Z</published>
    <updated>2019-11-12T05:49:07.666Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>deepin 搭建hexo</title>
    <link href="http://yoursite.com/2019/11/12/deepin-%E6%90%AD%E5%BB%BAhexo/"/>
    <id>http://yoursite.com/2019/11/12/deepin-搭建hexo/</id>
    <published>2019-11-12T05:24:09.000Z</published>
    <updated>2019-11-12T10:57:04.128Z</updated>
    
    <content type="html"><![CDATA[<h2 id="deepin系统下Hexo博客安装"><a href="#deepin系统下Hexo博客安装" class="headerlink" title="deepin系统下Hexo博客安装"></a>deepin系统下Hexo博客安装</h2><h3 id="0-更新和升级系统软件包"><a href="#0-更新和升级系统软件包" class="headerlink" title="0.更新和升级系统软件包"></a>0.更新和升级系统软件包</h3><p>首先，确保系统软件包是最新的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update &amp;&amp; sudo apt-get upgrade</span><br></pre></td></tr></table></figure><p>其次，如果要在github上创建一个重新发布目录，则应<a href="https://www.digitalocean.com/community/tutorials/how-to-install-git-on-ubuntu-14-04" target="_blank" rel="noopener">安装Git</a>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install git</span><br><span class="line">sudo apt install git-core -y</span><br></pre></td></tr></table></figure><p>注：上面m俩个语句应该都行，运行其中一句就行</p><h3 id="1-安装node-js"><a href="#1-安装node-js" class="headerlink" title="1.安装node.js"></a>1.安装node.js</h3><p>使用nvm（node.js版本管理器）<a href="https://www.digitalocean.com/community/tutorials/how-to-install-node-js-on-an-ubuntu-14-04-server#how-to-install-using-nvm" target="_blank" rel="noopener">安装node.js</a></p><h4 id="1-安装基本环境库"><a href="#1-安装基本环境库" class="headerlink" title="1.安装基本环境库"></a>1.安装基本环境库</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install build-essential libssl-dev</span><br></pre></td></tr></table></figure><h4 id="2-从nvm的GitHub页面上下拉nvm安装脚本并安装nvm"><a href="#2-从nvm的GitHub页面上下拉nvm安装脚本并安装nvm" class="headerlink" title="2.从nvm的GitHub页面上下拉nvm安装脚本并安装nvm"></a>2.从<a href="https://github.com/creationix/nvm" target="_blank" rel="noopener">nvm的GitHub页面上</a>下拉nvm安装脚本并安装nvm</h4><p>使用cURL：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl https://raw.github.com/creationix/nvm/master/install.sh | sh</span><br></pre></td></tr></table></figure><p>使用Wget：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -qO- https://raw.github.com/creationix/nvm/master/install.sh | sh</span><br></pre></td></tr></table></figure><h4 id="3-然后更新个人资料"><a href="#3-然后更新个人资料" class="headerlink" title="3.然后更新个人资料"></a>3.然后更新个人资料</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ~/.profile</span><br></pre></td></tr></table></figure><h4 id="4-安装node-js"><a href="#4-安装node-js" class="headerlink" title="4.安装node.js"></a>4.安装node.js</h4><p>找出可用于安装的Node.js版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">nvm ls-remote</span><br><span class="line">        ......</span><br><span class="line">         v6.5.0</span><br><span class="line">         v6.6.0</span><br><span class="line">         v6.7.0</span><br><span class="line">         v6.8.0</span><br><span class="line">         v6.8.1</span><br><span class="line">         v6.9.0   (LTS: Boron)</span><br><span class="line">         v6.9.1   (LTS: Boron)</span><br><span class="line">         v6.9.2   (LTS: Boron)</span><br><span class="line">         v6.9.3   (LTS: Boron)</span><br><span class="line">         v6.9.4   (LTS: Boron)</span><br><span class="line">         v6.9.5   (LTS: Boron)</span><br><span class="line">         v6.10.0   (LTS: Boron)</span><br><span class="line">         v6.10.1   (Latest LTS: Boron)</span><br><span class="line">         v7.0.0</span><br><span class="line">        ......</span><br></pre></td></tr></table></figure><p>如我们所见，最新的LTS是6.10.1，我们可以安装它并明确声明使用版本是6.10.1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nvm install 6.10.1</span><br><span class="line">nvm use 6.10.1</span><br></pre></td></tr></table></figure><p>如果您有多个Node.js版本，则可以通过键入以下内容查看安装的内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvm ls</span><br></pre></td></tr></table></figure><p>如果您希望默认使用其中一个版本，则可以输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvm alias default 6.10.1</span><br></pre></td></tr></table></figure><p>产生新会话时，将自动选择此版本。您还可以通过如下别名来引用它：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvm use default</span><br></pre></td></tr></table></figure><h3 id="2-安装hexo"><a href="#2-安装hexo" class="headerlink" title="2.安装hexo"></a>2.安装hexo</h3><p>使用npm（node.js软件包管理器）<a href="https://www.digitalocean.com/community/tutorials/how-to-create-a-blog-with-hexo-on-ubuntu-14-04" target="_blank" rel="noopener">安装hexo</a>。</p><h4 id="1-安装最重要的hexo-cli，并提供核心Hexo命令。"><a href="#1-安装最重要的hexo-cli，并提供核心Hexo命令。" class="headerlink" title="1.安装最重要的hexo-cli，并提供核心Hexo命令。"></a>1.安装最重要的<em>hexo-cli</em>，并提供核心Hexo命令。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure><h4 id="2-安装内置服务器hexo-server。"><a href="#2-安装内置服务器hexo-server。" class="headerlink" title="2.安装内置服务器hexo- server。"></a>2.安装<em>内置服务器hexo-</em> server。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-server -g</span><br></pre></td></tr></table></figure><blockquote><p>安装程序包抛出错误：sh：1：节点：权限被拒绝</p></blockquote><p>固定：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config set unsafe-perm true</span><br></pre></td></tr></table></figure><p>说明：</p><blockquote><p>unsafe-perm：如果以root用户身份运行，则为false（默认），否则为true。设置为true以在运行时禁止UID / GID切换</p></blockquote><h4 id="3-初始化hexo主目录并安装博客项目。"><a href="#3-初始化hexo主目录并安装博客项目。" class="headerlink" title="3.初始化hexo主目录并安装博客项目。"></a>3.初始化hexo主目录并安装博客项目。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mkdir Blog</span><br><span class="line">cd Blog/</span><br><span class="line">mkdir hexo</span><br><span class="line">cd hexo/</span><br><span class="line">hexo init</span><br></pre></td></tr></table></figure><h4 id="4、测试安装成功"><a href="#4、测试安装成功" class="headerlink" title="4、测试安装成功"></a>4、测试安装成功</h4><p>打开 Hexo 服务</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure><p>此时打开浏览器访问自己【主机的ip：4000】就可以看到我们搭建成功的博客页面。</p><p>但是这仅仅是本地的，接下来把博客部署到 GitHub 上面我们就可以脱离本地访问了。</p><h3 id="三、-将博客部署到-GitHub"><a href="#三、-将博客部署到-GitHub" class="headerlink" title="三、 将博客部署到 GitHub"></a>三、 将博客部署到 GitHub</h3><h4 id="1、注册-GitHub"><a href="#1、注册-GitHub" class="headerlink" title="1、注册 GitHub"></a>1、注册 GitHub</h4><p>​    </p><p>如果没有GitHub账户的先去去注册GitHub账户，有GitHub账户的直接下一步;</p><h4 id="2、设置-user-name-和-user-email"><a href="#2、设置-user-name-和-user-email" class="headerlink" title="2、设置 user.name 和 user.email"></a>2、设置 user.name 和 user.email</h4><p>注册好之后回来自己的机器上</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;Your user.name&quot;</span><br><span class="line">git config --global user.email &quot;You user.email&quot;</span><br></pre></td></tr></table></figure><p>“ “里面换成自己的user.name和user.email;</p><p>3、生成 shh 密匙<br>ssh-keygen -t rsa -C user.email<br>下面提示输入要保存到的路径，我们输入</p><p> /home/ubuntu/.ssh/id_rsa<br>然后下面直接回车回车；</p><p>4、查看 shh 密匙<br> vim /home/ubuntu/.ssh/id_rsa<br>把密匙复制一下，接下来去 GitHub 账户下添加 SSH key；</p><p>5、在 GitHub 账户添加 SSH key<br>添加 ssh key ，点击传送；</p><p>6、创建 GitHub 仓库<br>命名格式为”账户的userName”.github.io</p><p>例如 ： zhangsan.github.io</p><p>去<a href="传送">创建GitHub仓库</a></p><p>7、修改 hexo 配置文件<br>进入到自己的hexo 安装目录下 ，打开_config.yml文件</p><p>修改下面这部分；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">    type: git</span><br><span class="line">    repo: git@github.com:(BoView)/(BoView).github.io.git #括号里面换成自己的用户名和仓库名,去掉括号</span><br><span class="line">    branch: master</span><br></pre></td></tr></table></figure><h4 id="8、部署"><a href="#8、部署" class="headerlink" title="8、部署"></a>8、部署</h4><p>安装 hexo-deployer-git 插件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//生成静态页面</span><br><span class="line">hexo g</span><br><span class="line">//将public文件内容部署到github仓库</span><br><span class="line">hexo d</span><br><span class="line">//这两条是常用的命令，后者也可以这样</span><br><span class="line">hexo d -g</span><br><span class="line">//或者</span><br><span class="line">hexo g -d</span><br></pre></td></tr></table></figure><p>此时可以打开浏览器访问userName.github.io(GitHub仓库名)</p><p>即可以访问到搭建的博客页面</p><p>到这里基本完成任务了，但是我们想更完美一点，再绑定个域名，然后用域名访问岂不美哉；</p><h5 id="还有bug的话，Google解决！！！！！！！！！"><a href="#还有bug的话，Google解决！！！！！！！！！" class="headerlink" title="**         还有bug的话，Google解决！！！！！！！！！**"></a>**         还有bug的话，Google解决！！！！！！！！！**</h5>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;deepin系统下Hexo博客安装&quot;&gt;&lt;a href=&quot;#deepin系统下Hexo博客安装&quot; class=&quot;headerlink&quot; title=&quot;deepin系统下Hexo博客安装&quot;&gt;&lt;/a&gt;deepin系统下Hexo博客安装&lt;/h2&gt;&lt;h3 id=&quot;0-更新和
      
    
    </summary>
    
    
      <category term="hexo" scheme="http://yoursite.com/categories/hexo/"/>
    
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>c++（内部）排序算法</title>
    <link href="http://yoursite.com/2019/11/12/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2019/11/12/排序算法总结/</id>
    <published>2019-11-12T02:11:11.000Z</published>
    <updated>2019-11-12T11:07:47.980Z</updated>
    
    <content type="html"><![CDATA[<p>基本概念<br>内部和外部排序<br>内部排序在这里指的是只用到了电脑内存而不使用外存的排序方式。相对的，外部排序就是同时动用了电脑内存和外存的排序方式。本文在这里只讨论内部排序。</p><p>分类<br>比较和非比较排序<br>比较在这里指的是需要比较两个元素的大小(前后)才能进行的排序。难道有排序算法不需要比较吗？的确有，但是不多。常见的有三种：计数排序，桶排序，基数排序。它们用统计的方法规避了比较，详细的可查看之后讲到的这些算法。</p><p>转换<br>每次只调换两个元素之间的位置。</p><p>插入<br>遍历到的元素放入之前维护的已完成排序的序列中。</p><p>选择<br>选择剩余元素中最大或最小的元素。</p><p><img src="/2019/11/12/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/1.png" alt="1"></p><h2 id="稳定度-Stability"><a href="#稳定度-Stability" class="headerlink" title="稳定度 (Stability)"></a>稳定度 (Stability)</h2><p>定义：如果排序算法并不改变两个相同值的元素的相对位置，则此算法稳定度高。</p><p>这张图十分形象地解释了以上定义：</p><p><strong>我的理解：当数据中存在俩个或俩个以上键值相等的元素时，这些元素在在排序前后顺序不变。</strong></p><p><strong>（不相邻的元素在排序中不会直接交换顺序）</strong></p><p><img src="/2019/11/12/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/3.png" alt="3"></p><h1 id="冒泡排序-Bubble-Sort"><a href="#冒泡排序-Bubble-Sort" class="headerlink" title="冒泡排序 (Bubble Sort)"></a>冒泡排序 (Bubble Sort)</h1><hr><h2 id="1-算法"><a href="#1-算法" class="headerlink" title="1 算法"></a>1 算法</h2><p>从第一个元素开始遍历，比较当前元素跟下一个元素的大小，如果不符合排序，交换位置。结束最后一个元素后，再从头开始不断遍历，直到完成排序。</p><h4 id="2-代码"><a href="#2-代码" class="headerlink" title="2 代码"></a>2 代码</h4><h5 id="基本"><a href="#基本" class="headerlink" title="基本"></a><strong>基本</strong></h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubble</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.size()<span class="number">-1</span>;i++)&#123; <span class="comment">//only need n-1 swaps to move the smallest to the front</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;arr.size()<span class="number">-1</span>;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(arr[j]&gt;arr[j+<span class="number">1</span>]) swap(arr[j],arr[j+<span class="number">1</span>]);</span><br><span class="line"><span class="comment">//arr[j]&gt;arr[j+1] stable</span></span><br><span class="line"><span class="comment">//arr[j]&gt;=arr[j+1] unstable</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="优化1-每遍历完一遍，看是否已经提前完成排序-用-hasSorted-。如是，提早结束。"><a href="#优化1-每遍历完一遍，看是否已经提前完成排序-用-hasSorted-。如是，提早结束。" class="headerlink" title="优化1: 每遍历完一遍，看是否已经提前完成排序(用 hasSorted)。如是，提早结束。"></a>优化1: 每遍历完一遍，看是否已经提前完成排序(用 hasSorted)。如是，提早结束。</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubble1</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr)</span></span>&#123;</span><br><span class="line"><span class="keyword">bool</span> hasSorted = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.size()<span class="number">-1</span>&amp;&amp;!hasSorted;i++)&#123;</span><br><span class="line">hasSorted=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;arr.size()<span class="number">-1</span>;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(arr[j]&gt;arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">hasSorted = <span class="literal">false</span>;</span><br><span class="line">swap(arr[j],arr[j+<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="优化2-根据“剖析：每遍历完一次，最小数前进一位，但是最大数到达最终位；末尾已经是最终排序。”，每遍历完一次，里面的loop就可以少遍历一个元素。但其实由此我们可以推论，最后一个swap的j和j-1-j之后的元素-不包括j-都已经完成排序了。"><a href="#优化2-根据“剖析：每遍历完一次，最小数前进一位，但是最大数到达最终位；末尾已经是最终排序。”，每遍历完一次，里面的loop就可以少遍历一个元素。但其实由此我们可以推论，最后一个swap的j和j-1-j之后的元素-不包括j-都已经完成排序了。" class="headerlink" title="优化2: 根据“剖析：每遍历完一次，最小数前进一位，但是最大数到达最终位；末尾已经是最终排序。”，每遍历完一次，里面的loop就可以少遍历一个元素。但其实由此我们可以推论，最后一个swap的j和j+1, j之后的元素(不包括j)都已经完成排序了。"></a><strong>优化2:</strong> 根据“剖析：每遍历完一次，最小数前进一位，但是最大数到达最终位；末尾已经是最终排序。”，每遍历完一次，里面的loop就可以少遍历一个元素。但其实由此我们可以推论，最后一个swap的j和j+1, j之后的元素(不包括j)都已经完成排序了。</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubble2</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = arr.size()<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.size()<span class="number">-1</span>;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> upto = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;<span class="comment">//j小于不定排序的最后一位</span></span><br><span class="line"><span class="keyword">if</span>(arr[j]&gt;arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">upto = j;<span class="comment">//upto=j不定大小的最后一位, j+1 已经完成排序（最后一个if）</span></span><br><span class="line">swap(arr[j],arr[j+<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">n=upto;</span><br><span class="line"><span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="优化3-可以进行双向的循环，正向循环把最大元素移动到末尾，逆向循环把最小元素移动到最前，这种优化过的冒泡排序，被称为鸡尾酒排序-Cocktail-Sort"><a href="#优化3-可以进行双向的循环，正向循环把最大元素移动到末尾，逆向循环把最小元素移动到最前，这种优化过的冒泡排序，被称为鸡尾酒排序-Cocktail-Sort" class="headerlink" title="优化3: 可以进行双向的循环，正向循环把最大元素移动到末尾，逆向循环把最小元素移动到最前，这种优化过的冒泡排序，被称为鸡尾酒排序(Cocktail Sort)"></a><strong>优化3</strong>: 可以进行双向的循环，正向循环把最大元素移动到末尾，逆向循环把最小元素移动到最前，这种优化过的冒泡排序，被称为鸡尾酒排序(Cocktail Sort)</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubble4</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> beg = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> end = arr.size()<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span>(beg&lt;end)&#123;</span><br><span class="line"><span class="keyword">int</span> nbeg = beg, nend = end;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//正向循环</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=beg;i&lt;end;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(arr[i]&gt;arr[i+<span class="number">1</span>])&#123;</span><br><span class="line">nend=i;</span><br><span class="line">swap(arr[i],arr[i+<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(nend==end) <span class="keyword">break</span>;</span><br><span class="line">end = nend;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//逆向循环</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=end; i&gt;beg;i--)&#123;</span><br><span class="line"><span class="keyword">if</span>(arr[i]&lt;arr[i<span class="number">-1</span>])&#123;</span><br><span class="line">nbeg=i;</span><br><span class="line">swap(arr[i], arr[i<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(nbeg==beg) <span class="keyword">break</span>;</span><br><span class="line">beg = nbeg;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-分析"><a href="#3-分析" class="headerlink" title="3 分析"></a>3 分析</h4><h5 id="3-1-稳定度"><a href="#3-1-稳定度" class="headerlink" title="3.1 稳定度"></a>3.1 稳定度</h5><p>决定于比较的时候用的是大于等于(小于等于)还是大于(小于)</p><p>arr[i]&gt;arr[i+1] –&gt; 稳定</p><p>arr[i]&gt;=arr[i+1] –&gt; 不稳定</p><h5 id="3-2-时间"><a href="#3-2-时间" class="headerlink" title="3.2 时间"></a>3.2 时间</h5><p>逆向排序时是最差的情况，O(n^2)</p><h5 id="3-3-空间"><a href="#3-3-空间" class="headerlink" title="3.3 空间"></a><strong>3.3 空间</strong></h5><p>需要O(1)来完成swap等</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;基本概念&lt;br&gt;内部和外部排序&lt;br&gt;内部排序在这里指的是只用到了电脑内存而不使用外存的排序方式。相对的，外部排序就是同时动用了电脑内存和外存的排序方式。本文在这里只讨论内部排序。&lt;/p&gt;
&lt;p&gt;分类&lt;br&gt;比较和非比较排序&lt;br&gt;比较在这里指的是需要比较两个元素的大小(前
      
    
    </summary>
    
    
      <category term="ACM" scheme="http://yoursite.com/categories/ACM/"/>
    
    
      <category term="sort" scheme="http://yoursite.com/tags/sort/"/>
    
  </entry>
  
  <entry>
    <title>leetcode之前的几道小题</title>
    <link href="http://yoursite.com/2019/11/11/leetcode%E4%B9%8B%E5%89%8D%E7%9A%84%E5%87%A0%E9%81%93%E5%B0%8F%E9%A2%98/"/>
    <id>http://yoursite.com/2019/11/11/leetcode之前的几道小题/</id>
    <published>2019-11-11T10:16:22.000Z</published>
    <updated>2019-11-12T10:54:34.794Z</updated>
    
    <content type="html"><![CDATA[<h3 id="leetcode-1232-缀点成线"><a href="#leetcode-1232-缀点成线" class="headerlink" title="leetcode 1232.缀点成线"></a>leetcode 1232.缀点成线</h3><p>在一个 XY 坐标系中有一些点，我们用数组 coordinates 来分别记录它们的坐标，其中 coordinates[i] = [x, y] 表示横坐标为 x、纵坐标为 y 的点。</p><p>请你来判断，这些点是否在该坐标系中属于同一条直线上，是则返回 true，否则请返回 false。</p><p>示例 1：</p><p><img src="/2019/11/11/leetcode%E4%B9%8B%E5%89%8D%E7%9A%84%E5%87%A0%E9%81%93%E5%B0%8F%E9%A2%98/1.jpg" alt="1"></p><p>输入：coordinates = [[1,2],[2,3],[3,4],[4,5],[5,6],[6,7]]<br>输出：true<br>示例 2：</p><p><img src="/2019/11/11/leetcode%E4%B9%8B%E5%89%8D%E7%9A%84%E5%87%A0%E9%81%93%E5%B0%8F%E9%A2%98/2.jpg" alt="2"></p><p>输入：coordinates = [[1,1],[2,2],[3,4],[4,5],[5,6],[7,7]]<br>输出：false</p><p>提示：</p><p>2 &lt;= coordinates.length &lt;= 1000<br>coordinates[i].length == 2<br>-10^4 &lt;= coordinates[i][0], coordinates[i][1] &lt;= 10^4<br>coordinates 中不含重复的点</p><h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><p>两点 A(x0, y0) B(x1, y1) 确定一条直线， 直线的斜率为 k = (y1 - y0) / (x1 - x0)<br>所以我们只要遍历数组，判断当前点和上个点构成的直线的斜率是否和之前相同即可。</p><p>这里不需要求出 k，因为直接求出 k 可能为浮点数，不一定精确，所以我们用交叉相乘判断相等即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkStraightLine</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; coordinates)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">int</span> x=coordinates[<span class="number">1</span>][<span class="number">0</span>]-coordinates[<span class="number">0</span>][<span class="number">0</span>],y=coordinates[<span class="number">1</span>][<span class="number">1</span>]-coordinates[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;(<span class="keyword">int</span>)coordinates.size()<span class="number">-1</span>;++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> xx=coordinates[i+<span class="number">1</span>][<span class="number">0</span>]-coordinates[i][<span class="number">0</span>],yy=coordinates[i+<span class="number">1</span>][<span class="number">1</span>]-coordinates[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (yy*x!=y*xx) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="leetcode-1221-分割平衡字符串"><a href="#leetcode-1221-分割平衡字符串" class="headerlink" title="leetcode 1221.分割平衡字符串"></a>leetcode 1221.分割平衡字符串</h3><p>在一个「平衡字符串」中，’L’ 和 ‘R’ 字符的数量是相同的。</p><p>给出一个平衡字符串 s，请你将它分割成尽可能多的平衡字符串。</p><p>返回可以通过分割得到的平衡字符串的最大数量。</p><p>示例 1：</p><p>输入：s = “RLRRLLRLRL”<br>输出：4<br>解释：s 可以分割为 “RL”, “RRLL”, “RL”, “RL”, 每个子字符串中都包含相同数量的 ‘L’ 和 ‘R’。<br>示例 2：</p><p>输入：s = “RLLLLRRRLR”<br>输出：3<br>解释：s 可以分割为 “RL”, “LLLRRR”, “LR”, 每个子字符串中都包含相同数量的 ‘L’ 和 ‘R’。<br>示例 3：</p><p>输入：s = “LLLLRRRR”<br>输出：1<br>解释：s 只能保持原样 “LLLLRRRR”.</p><p>提示：</p><p>1 &lt;= s.length &lt;= 1000<br>s[i] = ‘L’ 或 ‘R’</p><h4 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h4><p>贪心算法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">balancedStringSplit</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> R = count(s.begin(),s.end(),<span class="string">'R'</span>),L = R;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it : s)&#123;</span><br><span class="line">        <span class="keyword">if</span>(it == <span class="string">'R'</span>) --R;</span><br><span class="line">        <span class="keyword">else</span> --L;</span><br><span class="line">        <span class="keyword">if</span>(L == R) ++ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="LeetCode-1-俩数之和"><a href="#LeetCode-1-俩数之和" class="headerlink" title="LeetCode 1.俩数之和"></a>LeetCode 1.俩数之和</h3><p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p><p>示例:</p><p>给定 nums = [2, 7, 11, 15], target = 9</p><p>因为 nums[0] + nums[1] = 2 + 7 = 9<br>所以返回 [0, 1]</p><h4 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h4><p>别人代码  看懂之后再写题解</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">hash_node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;            <span class="comment">/* we'll use this field as the key */</span></span><br><span class="line">    <span class="keyword">int</span> index;</span><br><span class="line">    UT_hash_handle hh; <span class="comment">/* makes this structure hashable */</span></span><br><span class="line">&#125; hash_node;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">twoSum</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize, <span class="keyword">int</span> target, <span class="keyword">int</span>* returnSize)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *two_nums = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*<span class="number">2</span>);</span><br><span class="line">    hash_node *hash_table = <span class="literal">NULL</span>, *hash_item1 = <span class="literal">NULL</span>, *hash_item2 = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numsSize; i++) &#123;</span><br><span class="line">        <span class="comment">// 查找哈希表中是否存在满足和为target的另一个值,若存在直接返回</span></span><br><span class="line">        <span class="keyword">int</span> other_id = target - *(nums+i);</span><br><span class="line">        HASH_FIND_INT(hash_table, &amp;other_id, hash_item1);</span><br><span class="line">        <span class="keyword">if</span> (hash_item1) &#123;</span><br><span class="line">            two_nums[<span class="number">0</span>] = hash_item1-&gt;index;</span><br><span class="line">            two_nums[<span class="number">1</span>] = i;</span><br><span class="line">            *returnSize = <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">return</span> two_nums;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将本次遍历的值放入哈希表,value为数组下标,key为对应数值</span></span><br><span class="line">        hash_item2 = (hash_node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(hash_node));</span><br><span class="line">        hash_item2-&gt;id = *(nums+i);</span><br><span class="line">        hash_item2-&gt;index = i;</span><br><span class="line">        HASH_ADD_INT(hash_table, id, hash_item2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> two_nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;leetcode-1232-缀点成线&quot;&gt;&lt;a href=&quot;#leetcode-1232-缀点成线&quot; class=&quot;headerlink&quot; title=&quot;leetcode 1232.缀点成线&quot;&gt;&lt;/a&gt;leetcode 1232.缀点成线&lt;/h3&gt;&lt;p&gt;在一个 XY
      
    
    </summary>
    
    
      <category term="ACM" scheme="http://yoursite.com/categories/ACM/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 162周赛题解</title>
    <link href="http://yoursite.com/2019/11/11/Leetcode-162%E5%91%A8%E8%B5%9B%E9%A2%98%E8%A7%A3/"/>
    <id>http://yoursite.com/2019/11/11/Leetcode-162周赛题解/</id>
    <published>2019-11-11T09:51:08.000Z</published>
    <updated>2019-11-12T10:54:45.936Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h4><p> <a href="https://leetcode-cn.com/contest/weekly-contest-162" target="_blank" rel="noopener">https://leetcode-cn.com/contest/weekly-contest-162</a> </p><h3 id="1253-重构-2-行二进制矩阵"><a href="#1253-重构-2-行二进制矩阵" class="headerlink" title="1253. 重构 2 行二进制矩阵"></a>1253. 重构 2 行二进制矩阵</h3><p>给你一个 <code>2</code> 行 <code>n</code> 列的二进制数组：</p><ul><li>矩阵是一个二进制矩阵，这意味着矩阵中的每个元素不是 <code>0</code> 就是 <code>1</code>。</li><li>第 <code>0</code> 行的元素之和为 <code>upper</code>。</li><li>第 <code>1</code> 行的元素之和为 <code>lower</code>。</li><li>第 <code>i</code> 列（从 <code>0</code> 开始编号）的元素之和为 <code>colsum[i]</code>，<code>colsum</code> 是一个长度为 <code>n</code> 的整数数组。</li></ul><p>你需要利用 <code>upper</code>，<code>lower</code> 和 <code>colsum</code> 来重构这个矩阵，并以二维整数数组的形式返回它。</p><p>如果有多个不同的答案，那么任意一个都可以通过本题。</p><p>如果不存在符合要求的答案，就请返回一个空的二维数组。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：upper = 2, lower = 1, colsum = [1,1,1]</span><br><span class="line">输出：[[1,1,0],[0,0,1]]</span><br><span class="line">解释：[[1,0,1],[0,1,0]] 和 [[0,1,1],[1,0,0]] 也是正确答案。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：upper = 2, lower = 3, colsum = [2,2,1,1]</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：upper = 5, lower = 5, colsum = [2,1,2,0,1,0,1,2,0,1]</span><br><span class="line">输出：[[1,1,1,0,1,0,0,1,0,0],[1,0,1,0,0,0,1,1,0,1]]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= colsum.length &lt;= 10^5</code></li><li><code>0 &lt;= upper, lower &lt;= colsum.length</code></li><li><code>0 &lt;= colsum[i] &lt;= 2</code></li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>首先题目一开始没看仔细，然后wa了一发，压压惊之后猛然发现矩阵中的元素不是0就是1这个条件，突然醒悟QAQ</p><p>首先判断一下有没有答案，我们来思考一下，矩阵的每行的和与每列的和肯定是相等的，所以说如果colsum和upper+lower都不相等的话那我们就可以直接返回空的vector&gt;了，然后当两个值是相同的时候就一定有答案吗？</p><p>答案是不一定的，这里举个例子</p><p>upper = 1，lower = 3，colsum = [2，2]</p><p>可以发现并没有答案，upper=1这个很致命</p><p>那么我们就发现了更深层次的问题，其实这个题就是upper和lower的分解问题（也就是upper和lower被colsum分解）</p><p>由于只有两行，但是可以有很多列，所以显而易见我们是按列从左到右去填值的（按行你可以试试，试出来算我输）</p><p>所以一共三种分解的情况（因为矩阵是二进制的矩阵）</p><ul><li><strong>colsum==0</strong>，代表矩阵这一列都是0，upper和lower也不会被减</li><li><strong>colsum==2</strong>，很和谐的情况，表示upper和lower都要减一，矩阵两行也都要填1</li><li><strong>colsum==1</strong>，upper和lower其中一个需要减一，那么肯定是两个中取大的那个减一，因为我们要尽可能的找到答案（如果upper或lower被减成负数显然没有答案）</li></ul><p>最后判断一下upper和lower有没有变成负数，变成负数就说明没答案了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; reconstructMatrix(<span class="keyword">int</span> upper, <span class="keyword">int</span> lower, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; colsum) &#123;</span><br><span class="line">        <span class="keyword">int</span> n=colsum.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; a(<span class="number">2</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n,<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            sum+=colsum[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>((upper+lower)!=sum)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(colsum[j]==<span class="number">0</span>)&#123;</span><br><span class="line">                    a[<span class="number">0</span>][j]=a[<span class="number">1</span>][j]=<span class="number">0</span>;                    </span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(colsum[j]==<span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(upper&gt;=lower)&#123;</span><br><span class="line">                        a[<span class="number">0</span>][j]=<span class="number">1</span>;</span><br><span class="line">                        upper-=<span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                        a[<span class="number">1</span>][j]=<span class="number">1</span>;</span><br><span class="line">                        lower-=<span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(colsum[j]==<span class="number">2</span>)&#123;</span><br><span class="line">                    a[<span class="number">0</span>][j]=a[<span class="number">1</span>][j]=<span class="number">1</span>;</span><br><span class="line">                    upper-=<span class="number">1</span>;</span><br><span class="line">                    lower-=<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">               </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(upper&lt;<span class="number">0</span>||lower&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;();</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>大佬写的直接copy，向大佬致敬！！！！！！！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; reconstructMatrix(<span class="keyword">int</span> upper, <span class="keyword">int</span> lower, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; col) &#123;</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x:col) sum+=x;</span><br><span class="line">        <span class="keyword">if</span>(sum!=upper+lower) <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> n=<span class="number">2</span>,m=col.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; v(n,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(m,<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(col[i]==<span class="number">2</span>)&#123;</span><br><span class="line">                v[<span class="number">0</span>][i]=v[<span class="number">1</span>][i]=<span class="number">1</span>;</span><br><span class="line">                upper--,lower--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(col[i]==<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(upper&gt;=lower) v[<span class="number">0</span>][i]=<span class="number">1</span>,upper--;</span><br><span class="line">                <span class="keyword">else</span> v[<span class="number">1</span>][i]=<span class="number">1</span>,lower--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(upper&lt;<span class="number">0</span>||lower&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;();</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="5255-奇数值单元格的数目"><a href="#5255-奇数值单元格的数目" class="headerlink" title="5255. 奇数值单元格的数目"></a>5255. 奇数值单元格的数目</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个 <code>n</code> 行 <code>m</code> 列的矩阵，最开始的时候，每个单元格中的值都是 <code>0</code>。</p><p>另有一个索引数组 <code>indices</code>，<code>indices[i] = [ri, ci]</code> 中的 <code>ri</code> 和 <code>ci</code> 分别表示指定的行和列（从 <code>0</code> 开始编号）。</p><p>你需要将每对 <code>[ri, ci]</code> 指定的行和列上的所有单元格的值加 <code>1</code>。</p><p>请你在执行完所有 <code>indices</code> 指定的增量操作后，返回矩阵中 「奇数值单元格」 的数目。</p><p><strong>示例 1：</strong></p><p><img src="/2019/11/11/Leetcode-162%E5%91%A8%E8%B5%9B%E9%A2%98%E8%A7%A3/2.png" alt="2"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 2, m = 3, indices = [[0,1],[1,1]]输出：6解释：最开始的矩阵是 [[0,0,0],[0,0,0]]。第一次增量操作后得到 [[1,2,1],[0,1,0]]。最后的矩阵是 [[1,3,1],[1,3,1]]，里面有 6 个奇数。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="/2019/11/11/Leetcode-162%E5%91%A8%E8%B5%9B%E9%A2%98%E8%A7%A3/1.png" alt="1"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 2, m = 2, indices = [[1,1],[0,0]]输出：0解释：最后的矩阵是 [[2,2],[2,2]]，里面没有奇数。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>1 &lt;= n &lt;= 50</li><li>1 &lt;= m &lt;= 50</li><li>1 &lt;= indices.length &lt;= 100</li><li>0 &lt;= indices[i][0] &lt; n</li><li>0 &lt;= indices[i][1] &lt; m</li></ul><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>这题是一个简单的模拟题，我们只需要跟着题目的描述操作就可以</p><p>首先我们创建一个新的二维向量，然后遍历indices这个vector然后对相应地位置+1即可</p><p>最后我们遍历二维向量统计奇数个数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">oddCells</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; indices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a[n][m];</span><br><span class="line">        <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="keyword">sizeof</span>(a));</span><br><span class="line">        <span class="comment">//cout&lt;&lt;indices.size()&lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;indices.size()*<span class="number">2</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> j=indices[i/<span class="number">2</span>][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> c=<span class="number">0</span>;c&lt;m;c++)&#123;                </span><br><span class="line">                    a[j][c]+=<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> k=indices[i/<span class="number">2</span>][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> r=<span class="number">0</span>;r&lt;n;r++)&#123;</span><br><span class="line">                    a[r][k]+=<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">                <span class="comment">//cout&lt;&lt;a[i][j]&lt;&lt;"\t";</span></span><br><span class="line">                <span class="keyword">if</span>(a[i][j]%<span class="number">2</span>==<span class="number">1</span>)</span><br><span class="line">                    cnt+=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//cout&lt;&lt;endl;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>下面是大佬的  值得学习的那必须copy</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">oddCells</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; indices)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; v=<span class="built_in">vector</span>(n+<span class="number">10</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(m+<span class="number">10</span>,<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x:indices)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++) v[x[<span class="number">0</span>]][i]++;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) v[i][x[<span class="number">1</span>]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)</span><br><span class="line">                <span class="keyword">if</span>(v[i][j]&amp;<span class="number">1</span>) ans++;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这次就很努力，没有做完一道题就放弃了，但是超常发挥也只有俩题。看看大佬 不到一小时  AK  </p><p><img src="/2019/11/11/Leetcode-162%E5%91%A8%E8%B5%9B%E9%A2%98%E8%A7%A3/7.jpg" alt="7"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;题目链接&quot;&gt;&lt;a href=&quot;#题目链接&quot; class=&quot;headerlink&quot; title=&quot;题目链接&quot;&gt;&lt;/a&gt;题目链接&lt;/h4&gt;&lt;p&gt; &lt;a href=&quot;https://leetcode-cn.com/contest/weekly-contest-162&quot; 
      
    
    </summary>
    
    
      <category term="ACM" scheme="http://yoursite.com/categories/ACM/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
  </entry>
  
</feed>
