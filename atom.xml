<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>52hertz</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-11-15T09:55:12.458Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>52hertz</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Ubuntu下安装程序的三种方法</title>
    <link href="http://yoursite.com/2019/11/15/Ubuntu%E4%B8%8B%E5%AE%89%E8%A3%85%E7%A8%8B%E5%BA%8F%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2019/11/15/Ubuntu下安装程序的三种方法/</id>
    <published>2019-11-15T09:48:06.000Z</published>
    <updated>2019-11-15T09:55:12.458Z</updated>
    
    <content type="html"><![CDATA[<h3 id="UBUNTU下安装程序的三种方法"><a href="#UBUNTU下安装程序的三种方法" class="headerlink" title="UBUNTU下安装程序的三种方法"></a>UBUNTU下安装程序的三种方法</h3><p>在ubuntu当中，安装应用程序我所知道的有三种方法，分别是apt-get，dpkg安装deb和make install安装源码包三种。下面针对每一种方法各举例来说明。</p><h4 id="1-apt-get方法"><a href="#1-apt-get方法" class="headerlink" title="(1)apt-get方法"></a>(1)apt-get方法</h4><p>使用apt-get install来安装应用程序算是最常见的一种安装方法了，比如我要安装build-essential这个软件，使用以下，他会帮我把所有的依赖包都一起安装了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install 软件名</span><br></pre></td></tr></table></figure><p>执行上述命令以后，我们可以看到一下信息，The following extra packages will be installed:表示所有需要再安装的依赖包。</p><p>下面给出apt-get的的各种参数：</p><p>apt-get install xxx 安装xxx  。如果带有参数，那么-d 表示仅下载 ，-f 表示强制安装<br>apt-get remove xxx 卸载xxx<br>apt-get update 更新软件信息数据库<br>apt-get upgrade 进行系统升级<br>apt-cache search 搜索软件包<br>Tips：建议您经常使用“apt-get update”命令来更新您的软件信息数据库 </p><p>apt-get理论上是要求能够联网，但是如果制作了本地源，就不需要联网，制作本地源可以参考：<a href="http://www.cnblogs.com/xwdreamer/p/3875857.html" target="_blank" rel="noopener">ubuntu制作本地源</a></p><h4 id="2-dpkg安装deb包"><a href="#2-dpkg安装deb包" class="headerlink" title="(2)dpkg安装deb包"></a>(2)dpkg安装deb包</h4><p>Ubuntu软件包格式为deb，安装方法如下：</p><p>  sudo dpkg -i package.deb</p><p>dpkg的详细使用方法，网上有很多，下面简单列了几个：</p><p>dpkg -i package.deb安装包</p><p>dpkg -r package删除包</p><p>dpkg -P package删除包（包括配置文件）</p><p>dpkg -L package列出与该包关联的文件</p><p>dpkg -l package显示该包的版本</p><p>dpkg –unpack package.deb解开 deb 包的内容</p><p>dpkg -S keyword搜索所属的包内容</p><p>dpkg -l列出当前已安装的包</p><p>dpkg -c package.deb列出 deb 包的内容</p><p>dpkg –configure package配置包</p><h4 id="make-install源代码安装"><a href="#make-install源代码安装" class="headerlink" title="make install源代码安装"></a>make install源代码安装</h4><p>如果要使用make安装的话，那么必须得安装build-essential这个依赖包，安装方法已经在前面说过了。在安装完毕以后，我们就可以进行源码安装。源码安装大致可以分为三步骤：（./configure）–＞ 编译（sudo make） –＞ 安装（sudo make install）。</p><ol><li>配置：这是编译源代码的第一步，通过 <code>./configure</code> 命令完成。执行此步以便为编译源代码作准备。常用的选项有 <code>--</code>prefix=PREFIX，用以指定程序的安装位置。更多的选项可通过 <code>--</code>help 查询。也有某些程序无需执行此步。</li><li>编译：一旦配置通过，可即刻使用 <code>make</code> 指令来执行源代码的编译过程。视软件的具体情况而定，编译所需的时间也各有差异，我们所要做的就是耐心等候和静观其变。此步虽然仅下简单的指令，但有时候所遇到的问题却十分复杂。较常碰到的情形是程序编译到中途却无法圆满结束。此时，需要根据出错提示分析以便找到应对之策。</li><li>安装：如果编译没有问题，那么执行 <code>sudo make install</code> 就可以将程序安装到系统中了。</li></ol><p>下面以安装nagios为例进行说明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//1.解压缩</span><br><span class="line">tar -zxf nagios-4.0.2.tar.gz  </span><br><span class="line">//2.进入目录</span><br><span class="line">cd nagios-4.0.2</span><br><span class="line">//3.配置</span><br><span class="line">./configure --prefix=/usr/local/nagios     </span><br><span class="line">//4.编译</span><br><span class="line">make all</span><br><span class="line">//5.安装</span><br><span class="line">make install &amp;&amp; make install-init &amp;&amp; make install-commandmode &amp;&amp; make install-config</span><br></pre></td></tr></table></figure><h3 id="ubuntu制作本地源"><a href="#ubuntu制作本地源" class="headerlink" title="ubuntu制作本地源"></a>ubuntu制作本地源</h3><h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>平时apt-get install安装软件时，下载的deb文件都会存放在/var/cache/apt/archives/下，为了今后重装或给别人用，特别是没有网络时，这些deb文件实际上是可以派上用途的，也就是可以用这些deb制作成本地源。这种方法还有一个应用场景：</p><ol><li>先在有网络的服务器上面进行apt-get install安装</li><li>然后制作本地源</li><li>将本地源拷贝到没有网络的服务器上，然后在那台机器上设定sourcelist指向这个本地源，此时在那台没有网络的服务器上也可以执行apt-get install安装了。</li></ol><p>下面给出可行且实用的部分本地源制作步骤：</p><p>一、在自己的根目录下建立一个目录，用于放所有下载的软件包，目录名随自己喜欢,建议新手在自己的根目录下进行以下操作，以避免操作权限问题的困扰。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir ~/ packs</span><br></pre></td></tr></table></figure><p>拷贝过来发现在packs当中为文件都是root账户的，需要修改</p><p>修改所有者</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chown -R enadmin.enadmin *</span><br></pre></td></tr></table></figure><p> 修改权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod ug+rw,o+r *</span><br></pre></td></tr></table></figure><p>二、复制文件到packs文件夹下，目录依各人情况变化。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo cp /var/cache/apt/archives/* ~/packs -r</span><br></pre></td></tr></table></figure><p>三、建立Packages.gz包，里面记录了packs文件夹下面的软件包信息，包括依赖信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpkg-scanpackages packs /dev/null |gzip &gt; packs/Packages.gz -r</span><br></pre></td></tr></table></figure><p> 完成此操作后，将packs文件夹复制到一个不常格式化的分区中，作为长久使用，比如我将它放在一个fat32的分区时面，路径是 /media/packs</p><p>四、加本地源</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gedit /etc/apt/sources.list</span><br></pre></td></tr></table></figure><p>添加以下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deb file:///media/ packs/</span><br></pre></td></tr></table></figure><p>注意packs后面有一个斜杠，前面还要有空格</p><p>五、更新源</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;UBUNTU下安装程序的三种方法&quot;&gt;&lt;a href=&quot;#UBUNTU下安装程序的三种方法&quot; class=&quot;headerlink&quot; title=&quot;UBUNTU下安装程序的三种方法&quot;&gt;&lt;/a&gt;UBUNTU下安装程序的三种方法&lt;/h3&gt;&lt;p&gt;在ubuntu当中，安装应用
      
    
    </summary>
    
    
      <category term="hexo" scheme="http://yoursite.com/categories/hexo/"/>
    
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>字符串匹配</title>
    <link href="http://yoursite.com/2019/11/12/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/"/>
    <id>http://yoursite.com/2019/11/12/字符串匹配/</id>
    <published>2019-11-12T06:01:58.000Z</published>
    <updated>2019-11-12T06:01:58.058Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>线段树</title>
    <link href="http://yoursite.com/2019/11/12/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    <id>http://yoursite.com/2019/11/12/线段树/</id>
    <published>2019-11-12T06:01:46.000Z</published>
    <updated>2019-11-12T06:01:46.511Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>数论</title>
    <link href="http://yoursite.com/2019/11/12/%E6%95%B0%E8%AE%BA/"/>
    <id>http://yoursite.com/2019/11/12/数论/</id>
    <published>2019-11-12T06:00:26.000Z</published>
    <updated>2019-11-12T06:00:26.654Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>拓扑排序</title>
    <link href="http://yoursite.com/2019/11/12/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2019/11/12/拓扑排序/</id>
    <published>2019-11-12T06:00:13.000Z</published>
    <updated>2019-11-12T06:00:13.893Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>并查集</title>
    <link href="http://yoursite.com/2019/11/12/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <id>http://yoursite.com/2019/11/12/并查集/</id>
    <published>2019-11-12T05:58:56.000Z</published>
    <updated>2019-11-12T05:58:56.416Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>单源最短路径问题</title>
    <link href="http://yoursite.com/2019/11/12/%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2019/11/12/单源最短路径问题/</id>
    <published>2019-11-12T05:58:37.000Z</published>
    <updated>2019-11-12T05:58:37.936Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>最小生成树</title>
    <link href="http://yoursite.com/2019/11/12/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
    <id>http://yoursite.com/2019/11/12/最小生成树/</id>
    <published>2019-11-12T05:58:10.000Z</published>
    <updated>2019-11-12T05:58:10.413Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>优先队列</title>
    <link href="http://yoursite.com/2019/11/12/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"/>
    <id>http://yoursite.com/2019/11/12/优先队列/</id>
    <published>2019-11-12T05:57:53.000Z</published>
    <updated>2019-11-12T05:57:53.580Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>二叉搜索树</title>
    <link href="http://yoursite.com/2019/11/12/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    <id>http://yoursite.com/2019/11/12/二叉搜索树/</id>
    <published>2019-11-12T05:57:40.000Z</published>
    <updated>2019-11-12T05:57:40.049Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>DFS+BFS</title>
    <link href="http://yoursite.com/2019/11/12/DFS-BFS/"/>
    <id>http://yoursite.com/2019/11/12/DFS-BFS/</id>
    <published>2019-11-12T05:57:00.000Z</published>
    <updated>2019-11-12T05:57:00.527Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>图</title>
    <link href="http://yoursite.com/2019/11/12/%E5%9B%BE/"/>
    <id>http://yoursite.com/2019/11/12/图/</id>
    <published>2019-11-12T05:56:29.000Z</published>
    <updated>2019-11-12T05:56:29.032Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>树</title>
    <link href="http://yoursite.com/2019/11/12/%E6%A0%91/"/>
    <id>http://yoursite.com/2019/11/12/树/</id>
    <published>2019-11-12T05:54:31.000Z</published>
    <updated>2019-11-12T05:54:31.183Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>动态规划DP</title>
    <link href="http://yoursite.com/2019/11/12/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92DP/"/>
    <id>http://yoursite.com/2019/11/12/动态规划DP/</id>
    <published>2019-11-12T05:54:09.000Z</published>
    <updated>2019-11-12T05:54:09.877Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>二分搜索，哈希</title>
    <link href="http://yoursite.com/2019/11/12/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%EF%BC%8C%E5%93%88%E5%B8%8C/"/>
    <id>http://yoursite.com/2019/11/12/二分搜索，哈希/</id>
    <published>2019-11-12T05:53:25.000Z</published>
    <updated>2019-11-12T05:53:25.636Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>c++ STL库函数</title>
    <link href="http://yoursite.com/2019/11/12/c-STL%E5%BA%93%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2019/11/12/c-STL库函数/</id>
    <published>2019-11-12T05:52:30.000Z</published>
    <updated>2019-11-12T05:52:30.223Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>递归和分治法</title>
    <link href="http://yoursite.com/2019/11/12/%E9%80%92%E5%BD%92%E5%92%8C%E5%88%86%E6%B2%BB%E6%B3%95/"/>
    <id>http://yoursite.com/2019/11/12/递归和分治法/</id>
    <published>2019-11-12T05:49:07.000Z</published>
    <updated>2019-11-12T05:49:07.666Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>deepin 搭建hexo</title>
    <link href="http://yoursite.com/2019/11/12/deepin-%E6%90%AD%E5%BB%BAhexo/"/>
    <id>http://yoursite.com/2019/11/12/deepin-搭建hexo/</id>
    <published>2019-11-12T05:24:09.000Z</published>
    <updated>2019-11-12T10:57:04.128Z</updated>
    
    <content type="html"><![CDATA[<h2 id="deepin系统下Hexo博客安装"><a href="#deepin系统下Hexo博客安装" class="headerlink" title="deepin系统下Hexo博客安装"></a>deepin系统下Hexo博客安装</h2><h3 id="0-更新和升级系统软件包"><a href="#0-更新和升级系统软件包" class="headerlink" title="0.更新和升级系统软件包"></a>0.更新和升级系统软件包</h3><p>首先，确保系统软件包是最新的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update &amp;&amp; sudo apt-get upgrade</span><br></pre></td></tr></table></figure><p>其次，如果要在github上创建一个重新发布目录，则应<a href="https://www.digitalocean.com/community/tutorials/how-to-install-git-on-ubuntu-14-04" target="_blank" rel="noopener">安装Git</a>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install git</span><br><span class="line">sudo apt install git-core -y</span><br></pre></td></tr></table></figure><p>注：上面m俩个语句应该都行，运行其中一句就行</p><h3 id="1-安装node-js"><a href="#1-安装node-js" class="headerlink" title="1.安装node.js"></a>1.安装node.js</h3><p>使用nvm（node.js版本管理器）<a href="https://www.digitalocean.com/community/tutorials/how-to-install-node-js-on-an-ubuntu-14-04-server#how-to-install-using-nvm" target="_blank" rel="noopener">安装node.js</a></p><h4 id="1-安装基本环境库"><a href="#1-安装基本环境库" class="headerlink" title="1.安装基本环境库"></a>1.安装基本环境库</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install build-essential libssl-dev</span><br></pre></td></tr></table></figure><h4 id="2-从nvm的GitHub页面上下拉nvm安装脚本并安装nvm"><a href="#2-从nvm的GitHub页面上下拉nvm安装脚本并安装nvm" class="headerlink" title="2.从nvm的GitHub页面上下拉nvm安装脚本并安装nvm"></a>2.从<a href="https://github.com/creationix/nvm" target="_blank" rel="noopener">nvm的GitHub页面上</a>下拉nvm安装脚本并安装nvm</h4><p>使用cURL：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl https://raw.github.com/creationix/nvm/master/install.sh | sh</span><br></pre></td></tr></table></figure><p>使用Wget：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -qO- https://raw.github.com/creationix/nvm/master/install.sh | sh</span><br></pre></td></tr></table></figure><h4 id="3-然后更新个人资料"><a href="#3-然后更新个人资料" class="headerlink" title="3.然后更新个人资料"></a>3.然后更新个人资料</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ~/.profile</span><br></pre></td></tr></table></figure><h4 id="4-安装node-js"><a href="#4-安装node-js" class="headerlink" title="4.安装node.js"></a>4.安装node.js</h4><p>找出可用于安装的Node.js版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">nvm ls-remote</span><br><span class="line">        ......</span><br><span class="line">         v6.5.0</span><br><span class="line">         v6.6.0</span><br><span class="line">         v6.7.0</span><br><span class="line">         v6.8.0</span><br><span class="line">         v6.8.1</span><br><span class="line">         v6.9.0   (LTS: Boron)</span><br><span class="line">         v6.9.1   (LTS: Boron)</span><br><span class="line">         v6.9.2   (LTS: Boron)</span><br><span class="line">         v6.9.3   (LTS: Boron)</span><br><span class="line">         v6.9.4   (LTS: Boron)</span><br><span class="line">         v6.9.5   (LTS: Boron)</span><br><span class="line">         v6.10.0   (LTS: Boron)</span><br><span class="line">         v6.10.1   (Latest LTS: Boron)</span><br><span class="line">         v7.0.0</span><br><span class="line">        ......</span><br></pre></td></tr></table></figure><p>如我们所见，最新的LTS是6.10.1，我们可以安装它并明确声明使用版本是6.10.1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nvm install 6.10.1</span><br><span class="line">nvm use 6.10.1</span><br></pre></td></tr></table></figure><p>如果您有多个Node.js版本，则可以通过键入以下内容查看安装的内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvm ls</span><br></pre></td></tr></table></figure><p>如果您希望默认使用其中一个版本，则可以输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvm alias default 6.10.1</span><br></pre></td></tr></table></figure><p>产生新会话时，将自动选择此版本。您还可以通过如下别名来引用它：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvm use default</span><br></pre></td></tr></table></figure><h3 id="2-安装hexo"><a href="#2-安装hexo" class="headerlink" title="2.安装hexo"></a>2.安装hexo</h3><p>使用npm（node.js软件包管理器）<a href="https://www.digitalocean.com/community/tutorials/how-to-create-a-blog-with-hexo-on-ubuntu-14-04" target="_blank" rel="noopener">安装hexo</a>。</p><h4 id="1-安装最重要的hexo-cli，并提供核心Hexo命令。"><a href="#1-安装最重要的hexo-cli，并提供核心Hexo命令。" class="headerlink" title="1.安装最重要的hexo-cli，并提供核心Hexo命令。"></a>1.安装最重要的<em>hexo-cli</em>，并提供核心Hexo命令。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure><h4 id="2-安装内置服务器hexo-server。"><a href="#2-安装内置服务器hexo-server。" class="headerlink" title="2.安装内置服务器hexo- server。"></a>2.安装<em>内置服务器hexo-</em> server。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-server -g</span><br></pre></td></tr></table></figure><blockquote><p>安装程序包抛出错误：sh：1：节点：权限被拒绝</p></blockquote><p>固定：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config set unsafe-perm true</span><br></pre></td></tr></table></figure><p>说明：</p><blockquote><p>unsafe-perm：如果以root用户身份运行，则为false（默认），否则为true。设置为true以在运行时禁止UID / GID切换</p></blockquote><h4 id="3-初始化hexo主目录并安装博客项目。"><a href="#3-初始化hexo主目录并安装博客项目。" class="headerlink" title="3.初始化hexo主目录并安装博客项目。"></a>3.初始化hexo主目录并安装博客项目。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mkdir Blog</span><br><span class="line">cd Blog/</span><br><span class="line">mkdir hexo</span><br><span class="line">cd hexo/</span><br><span class="line">hexo init</span><br></pre></td></tr></table></figure><h4 id="4、测试安装成功"><a href="#4、测试安装成功" class="headerlink" title="4、测试安装成功"></a>4、测试安装成功</h4><p>打开 Hexo 服务</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure><p>此时打开浏览器访问自己【主机的ip：4000】就可以看到我们搭建成功的博客页面。</p><p>但是这仅仅是本地的，接下来把博客部署到 GitHub 上面我们就可以脱离本地访问了。</p><h3 id="三、-将博客部署到-GitHub"><a href="#三、-将博客部署到-GitHub" class="headerlink" title="三、 将博客部署到 GitHub"></a>三、 将博客部署到 GitHub</h3><h4 id="1、注册-GitHub"><a href="#1、注册-GitHub" class="headerlink" title="1、注册 GitHub"></a>1、注册 GitHub</h4><p>​    </p><p>如果没有GitHub账户的先去去注册GitHub账户，有GitHub账户的直接下一步;</p><h4 id="2、设置-user-name-和-user-email"><a href="#2、设置-user-name-和-user-email" class="headerlink" title="2、设置 user.name 和 user.email"></a>2、设置 user.name 和 user.email</h4><p>注册好之后回来自己的机器上</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;Your user.name&quot;</span><br><span class="line">git config --global user.email &quot;You user.email&quot;</span><br></pre></td></tr></table></figure><p>“ “里面换成自己的user.name和user.email;</p><p>3、生成 shh 密匙<br>ssh-keygen -t rsa -C user.email<br>下面提示输入要保存到的路径，我们输入</p><p> /home/ubuntu/.ssh/id_rsa<br>然后下面直接回车回车；</p><p>4、查看 shh 密匙<br> vim /home/ubuntu/.ssh/id_rsa<br>把密匙复制一下，接下来去 GitHub 账户下添加 SSH key；</p><p>5、在 GitHub 账户添加 SSH key<br>添加 ssh key ，点击传送；</p><p>6、创建 GitHub 仓库<br>命名格式为”账户的userName”.github.io</p><p>例如 ： zhangsan.github.io</p><p>去<a href="传送">创建GitHub仓库</a></p><p>7、修改 hexo 配置文件<br>进入到自己的hexo 安装目录下 ，打开_config.yml文件</p><p>修改下面这部分；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">    type: git</span><br><span class="line">    repo: git@github.com:(BoView)/(BoView).github.io.git #括号里面换成自己的用户名和仓库名,去掉括号</span><br><span class="line">    branch: master</span><br></pre></td></tr></table></figure><h4 id="8、部署"><a href="#8、部署" class="headerlink" title="8、部署"></a>8、部署</h4><p>安装 hexo-deployer-git 插件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//生成静态页面</span><br><span class="line">hexo g</span><br><span class="line">//将public文件内容部署到github仓库</span><br><span class="line">hexo d</span><br><span class="line">//这两条是常用的命令，后者也可以这样</span><br><span class="line">hexo d -g</span><br><span class="line">//或者</span><br><span class="line">hexo g -d</span><br></pre></td></tr></table></figure><p>此时可以打开浏览器访问userName.github.io(GitHub仓库名)</p><p>即可以访问到搭建的博客页面</p><p>到这里基本完成任务了，但是我们想更完美一点，再绑定个域名，然后用域名访问岂不美哉；</p><h5 id="还有bug的话，Google解决！！！！！！！！！"><a href="#还有bug的话，Google解决！！！！！！！！！" class="headerlink" title="**         还有bug的话，Google解决！！！！！！！！！**"></a>**         还有bug的话，Google解决！！！！！！！！！**</h5>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;deepin系统下Hexo博客安装&quot;&gt;&lt;a href=&quot;#deepin系统下Hexo博客安装&quot; class=&quot;headerlink&quot; title=&quot;deepin系统下Hexo博客安装&quot;&gt;&lt;/a&gt;deepin系统下Hexo博客安装&lt;/h2&gt;&lt;h3 id=&quot;0-更新和
      
    
    </summary>
    
    
      <category term="hexo" scheme="http://yoursite.com/categories/hexo/"/>
    
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>c++（内部）排序算法</title>
    <link href="http://yoursite.com/2019/11/12/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2019/11/12/排序算法总结/</id>
    <published>2019-11-12T02:11:11.000Z</published>
    <updated>2019-11-13T04:00:36.887Z</updated>
    
    <content type="html"><![CDATA[<p>基本概念<br>内部和外部排序<br>内部排序在这里指的是只用到了电脑内存而不使用外存的排序方式。相对的，外部排序就是同时动用了电脑内存和外存的排序方式。本文在这里只讨论内部排序。</p><p>分类<br>比较和非比较排序<br>比较在这里指的是需要比较两个元素的大小(前后)才能进行的排序。难道有排序算法不需要比较吗？的确有，但是不多。常见的有三种：计数排序，桶排序，基数排序。它们用统计的方法规避了比较，详细的可查看之后讲到的这些算法。</p><p>转换<br>每次只调换两个元素之间的位置。</p><p>插入<br>遍历到的元素放入之前维护的已完成排序的序列中。</p><p>选择<br>选择剩余元素中最大或最小的元素。</p><p><img src="/2019/11/12/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/1.png" alt="1"></p><h2 id="稳定度-Stability"><a href="#稳定度-Stability" class="headerlink" title="稳定度 (Stability)"></a>稳定度 (Stability)</h2><p>定义：如果排序算法并不改变两个相同值的元素的相对位置，则此算法稳定度高。</p><p>这张图十分形象地解释了以上定义：</p><p><strong>我的理解：当数据中存在俩个或俩个以上键值相等的元素时，这些元素在在排序前后顺序不变。</strong></p><p><strong>（不相邻的元素在排序中不会直接交换顺序）</strong></p><p><img src="/2019/11/12/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/3.png" alt="3"></p><h1 id="冒泡排序-Bubble-Sort"><a href="#冒泡排序-Bubble-Sort" class="headerlink" title="冒泡排序 (Bubble Sort)"></a>冒泡排序 (Bubble Sort)</h1><hr><h2 id="1-算法"><a href="#1-算法" class="headerlink" title="1 算法"></a>1 算法</h2><p>从第一个元素开始遍历，比较当前元素跟下一个元素的大小，如果不符合排序，交换位置。结束最后一个元素后，再从头开始不断遍历，直到完成排序。</p><h4 id="2-代码"><a href="#2-代码" class="headerlink" title="2 代码"></a>2 代码</h4><h5 id="基本"><a href="#基本" class="headerlink" title="基本"></a><strong>基本</strong></h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubble</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.size()<span class="number">-1</span>;i++)&#123; <span class="comment">//only need n-1 swaps to move the smallest to the front</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;arr.size()<span class="number">-1</span>;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(arr[j]&gt;arr[j+<span class="number">1</span>]) swap(arr[j],arr[j+<span class="number">1</span>]);</span><br><span class="line"><span class="comment">//arr[j]&gt;arr[j+1] stable</span></span><br><span class="line"><span class="comment">//arr[j]&gt;=arr[j+1] unstable</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="优化1-每遍历完一遍，看是否已经提前完成排序-用-hasSorted-。如是，提早结束。"><a href="#优化1-每遍历完一遍，看是否已经提前完成排序-用-hasSorted-。如是，提早结束。" class="headerlink" title="优化1: 每遍历完一遍，看是否已经提前完成排序(用 hasSorted)。如是，提早结束。"></a>优化1: 每遍历完一遍，看是否已经提前完成排序(用 hasSorted)。如是，提早结束。</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubble1</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr)</span></span>&#123;</span><br><span class="line"><span class="keyword">bool</span> hasSorted = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.size()<span class="number">-1</span>&amp;&amp;!hasSorted;i++)&#123;</span><br><span class="line">hasSorted=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;arr.size()<span class="number">-1</span>;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(arr[j]&gt;arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">hasSorted = <span class="literal">false</span>;</span><br><span class="line">swap(arr[j],arr[j+<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="优化2-根据“剖析：每遍历完一次，最小数前进一位，但是最大数到达最终位；末尾已经是最终排序。”，每遍历完一次，里面的loop就可以少遍历一个元素。但其实由此我们可以推论，最后一个swap的j和j-1-j之后的元素-不包括j-都已经完成排序了。"><a href="#优化2-根据“剖析：每遍历完一次，最小数前进一位，但是最大数到达最终位；末尾已经是最终排序。”，每遍历完一次，里面的loop就可以少遍历一个元素。但其实由此我们可以推论，最后一个swap的j和j-1-j之后的元素-不包括j-都已经完成排序了。" class="headerlink" title="优化2: 根据“剖析：每遍历完一次，最小数前进一位，但是最大数到达最终位；末尾已经是最终排序。”，每遍历完一次，里面的loop就可以少遍历一个元素。但其实由此我们可以推论，最后一个swap的j和j+1, j之后的元素(不包括j)都已经完成排序了。"></a><strong>优化2:</strong> 根据“剖析：每遍历完一次，最小数前进一位，但是最大数到达最终位；末尾已经是最终排序。”，每遍历完一次，里面的loop就可以少遍历一个元素。但其实由此我们可以推论，最后一个swap的j和j+1, j之后的元素(不包括j)都已经完成排序了。</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubble2</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = arr.size()<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.size()<span class="number">-1</span>;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> upto = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;<span class="comment">//j小于不定排序的最后一位</span></span><br><span class="line"><span class="keyword">if</span>(arr[j]&gt;arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">upto = j;<span class="comment">//upto=j不定大小的最后一位, j+1 已经完成排序（最后一个if）</span></span><br><span class="line">swap(arr[j],arr[j+<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">n=upto;</span><br><span class="line"><span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="优化3-可以进行双向的循环，正向循环把最大元素移动到末尾，逆向循环把最小元素移动到最前，这种优化过的冒泡排序，被称为鸡尾酒排序-Cocktail-Sort"><a href="#优化3-可以进行双向的循环，正向循环把最大元素移动到末尾，逆向循环把最小元素移动到最前，这种优化过的冒泡排序，被称为鸡尾酒排序-Cocktail-Sort" class="headerlink" title="优化3: 可以进行双向的循环，正向循环把最大元素移动到末尾，逆向循环把最小元素移动到最前，这种优化过的冒泡排序，被称为鸡尾酒排序(Cocktail Sort)"></a><strong>优化3</strong>: 可以进行双向的循环，正向循环把最大元素移动到末尾，逆向循环把最小元素移动到最前，这种优化过的冒泡排序，被称为鸡尾酒排序(Cocktail Sort)</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubble4</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> beg = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> end = arr.size()<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span>(beg&lt;end)&#123;</span><br><span class="line"><span class="keyword">int</span> nbeg = beg, nend = end;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//正向循环</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=beg;i&lt;end;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(arr[i]&gt;arr[i+<span class="number">1</span>])&#123;</span><br><span class="line">nend=i;</span><br><span class="line">swap(arr[i],arr[i+<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(nend==end) <span class="keyword">break</span>;</span><br><span class="line">end = nend;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//逆向循环</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=end; i&gt;beg;i--)&#123;</span><br><span class="line"><span class="keyword">if</span>(arr[i]&lt;arr[i<span class="number">-1</span>])&#123;</span><br><span class="line">nbeg=i;</span><br><span class="line">swap(arr[i], arr[i<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(nbeg==beg) <span class="keyword">break</span>;</span><br><span class="line">beg = nbeg;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-分析"><a href="#3-分析" class="headerlink" title="3 分析"></a>3 分析</h4><h5 id="3-1-稳定度"><a href="#3-1-稳定度" class="headerlink" title="3.1 稳定度"></a>3.1 稳定度</h5><p>决定于比较的时候用的是大于等于(小于等于)还是大于(小于)</p><p>arr[i]&gt;arr[i+1] –&gt; 稳定</p><p>arr[i]&gt;=arr[i+1] –&gt; 不稳定</p><h5 id="3-2-时间"><a href="#3-2-时间" class="headerlink" title="3.2 时间"></a>3.2 时间</h5><p>逆向排序时是最差的情况，O(n^2)</p><h5 id="3-3-空间"><a href="#3-3-空间" class="headerlink" title="3.3 空间"></a><strong>3.3 空间</strong></h5><p>需要O(1)来完成swap等</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;基本概念&lt;br&gt;内部和外部排序&lt;br&gt;内部排序在这里指的是只用到了电脑内存而不使用外存的排序方式。相对的，外部排序就是同时动用了电脑内存和外存的排序方式。本文在这里只讨论内部排序。&lt;/p&gt;
&lt;p&gt;分类&lt;br&gt;比较和非比较排序&lt;br&gt;比较在这里指的是需要比较两个元素的大小(前
      
    
    </summary>
    
    
      <category term="acm" scheme="http://yoursite.com/categories/acm/"/>
    
    
      <category term="sort" scheme="http://yoursite.com/tags/sort/"/>
    
  </entry>
  
  <entry>
    <title>leetcode之前的几道小题</title>
    <link href="http://yoursite.com/2019/11/11/leetcode%E4%B9%8B%E5%89%8D%E7%9A%84%E5%87%A0%E9%81%93%E5%B0%8F%E9%A2%98/"/>
    <id>http://yoursite.com/2019/11/11/leetcode之前的几道小题/</id>
    <published>2019-11-11T10:16:22.000Z</published>
    <updated>2019-11-13T05:12:10.486Z</updated>
    
    <content type="html"><![CDATA[<h3 id="leetcode-1232-缀点成线"><a href="#leetcode-1232-缀点成线" class="headerlink" title="leetcode 1232.缀点成线"></a>leetcode 1232.缀点成线</h3><p>在一个 XY 坐标系中有一些点，我们用数组 coordinates 来分别记录它们的坐标，其中 coordinates[i] = [x, y] 表示横坐标为 x、纵坐标为 y 的点。</p><p>请你来判断，这些点是否在该坐标系中属于同一条直线上，是则返回 true，否则请返回 false。</p><p>示例 1：</p><p><img src="/2019/11/11/leetcode%E4%B9%8B%E5%89%8D%E7%9A%84%E5%87%A0%E9%81%93%E5%B0%8F%E9%A2%98/1.jpg" alt="1"></p><p>输入：coordinates = [[1,2],[2,3],[3,4],[4,5],[5,6],[6,7]]<br>输出：true<br>示例 2：</p><p><img src="/2019/11/11/leetcode%E4%B9%8B%E5%89%8D%E7%9A%84%E5%87%A0%E9%81%93%E5%B0%8F%E9%A2%98/2.jpg" alt="2"></p><p>输入：coordinates = [[1,1],[2,2],[3,4],[4,5],[5,6],[7,7]]<br>输出：false</p><p>提示：</p><p>2 &lt;= coordinates.length &lt;= 1000<br>coordinates[i].length == 2<br>-10^4 &lt;= coordinates[i][0], coordinates[i][1] &lt;= 10^4<br>coordinates 中不含重复的点</p><h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><p>两点 A(x0, y0) B(x1, y1) 确定一条直线， 直线的斜率为 k = (y1 - y0) / (x1 - x0)<br>所以我们只要遍历数组，判断当前点和上个点构成的直线的斜率是否和之前相同即可。</p><p>这里不需要求出 k，因为直接求出 k 可能为浮点数，不一定精确，所以我们用交叉相乘判断相等即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkStraightLine</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; coordinates)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">int</span> x=coordinates[<span class="number">1</span>][<span class="number">0</span>]-coordinates[<span class="number">0</span>][<span class="number">0</span>],y=coordinates[<span class="number">1</span>][<span class="number">1</span>]-coordinates[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;(<span class="keyword">int</span>)coordinates.size()<span class="number">-1</span>;++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> xx=coordinates[i+<span class="number">1</span>][<span class="number">0</span>]-coordinates[i][<span class="number">0</span>],yy=coordinates[i+<span class="number">1</span>][<span class="number">1</span>]-coordinates[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (yy*x!=y*xx) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="leetcode-1221-分割平衡字符串"><a href="#leetcode-1221-分割平衡字符串" class="headerlink" title="leetcode 1221.分割平衡字符串"></a>leetcode 1221.分割平衡字符串</h3><p>在一个「平衡字符串」中，’L’ 和 ‘R’ 字符的数量是相同的。</p><p>给出一个平衡字符串 s，请你将它分割成尽可能多的平衡字符串。</p><p>返回可以通过分割得到的平衡字符串的最大数量。</p><p>示例 1：</p><p>输入：s = “RLRRLLRLRL”<br>输出：4<br>解释：s 可以分割为 “RL”, “RRLL”, “RL”, “RL”, 每个子字符串中都包含相同数量的 ‘L’ 和 ‘R’。<br>示例 2：</p><p>输入：s = “RLLLLRRRLR”<br>输出：3<br>解释：s 可以分割为 “RL”, “LLLRRR”, “LR”, 每个子字符串中都包含相同数量的 ‘L’ 和 ‘R’。<br>示例 3：</p><p>输入：s = “LLLLRRRR”<br>输出：1<br>解释：s 只能保持原样 “LLLLRRRR”.</p><p>提示：</p><p>1 &lt;= s.length &lt;= 1000<br>s[i] = ‘L’ 或 ‘R’</p><h4 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h4><p>贪心算法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">balancedStringSplit</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> R = count(s.begin(),s.end(),<span class="string">'R'</span>),L = R;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it : s)&#123;</span><br><span class="line">        <span class="keyword">if</span>(it == <span class="string">'R'</span>) --R;</span><br><span class="line">        <span class="keyword">else</span> --L;</span><br><span class="line">        <span class="keyword">if</span>(L == R) ++ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="LeetCode-1-俩数之和"><a href="#LeetCode-1-俩数之和" class="headerlink" title="LeetCode 1.俩数之和"></a>LeetCode 1.俩数之和</h3><p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p><p>示例:</p><p>给定 nums = [2, 7, 11, 15], target = 9</p><p>因为 nums[0] + nums[1] = 2 + 7 = 9<br>所以返回 [0, 1]</p><h4 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h4><p>别人代码  看懂之后再写题解</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">hash_node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;            <span class="comment">/* we'll use this field as the key */</span></span><br><span class="line">    <span class="keyword">int</span> index;</span><br><span class="line">    UT_hash_handle hh; <span class="comment">/* makes this structure hashable */</span></span><br><span class="line">&#125; hash_node;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">twoSum</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize, <span class="keyword">int</span> target, <span class="keyword">int</span>* returnSize)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *two_nums = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*<span class="number">2</span>);</span><br><span class="line">    hash_node *hash_table = <span class="literal">NULL</span>, *hash_item1 = <span class="literal">NULL</span>, *hash_item2 = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numsSize; i++) &#123;</span><br><span class="line">        <span class="comment">// 查找哈希表中是否存在满足和为target的另一个值,若存在直接返回</span></span><br><span class="line">        <span class="keyword">int</span> other_id = target - *(nums+i);</span><br><span class="line">        HASH_FIND_INT(hash_table, &amp;other_id, hash_item1);</span><br><span class="line">        <span class="keyword">if</span> (hash_item1) &#123;</span><br><span class="line">            two_nums[<span class="number">0</span>] = hash_item1-&gt;index;</span><br><span class="line">            two_nums[<span class="number">1</span>] = i;</span><br><span class="line">            *returnSize = <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">return</span> two_nums;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将本次遍历的值放入哈希表,value为数组下标,key为对应数值</span></span><br><span class="line">        hash_item2 = (hash_node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(hash_node));</span><br><span class="line">        hash_item2-&gt;id = *(nums+i);</span><br><span class="line">        hash_item2-&gt;index = i;</span><br><span class="line">        HASH_ADD_INT(hash_table, id, hash_item2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> two_nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;leetcode-1232-缀点成线&quot;&gt;&lt;a href=&quot;#leetcode-1232-缀点成线&quot; class=&quot;headerlink&quot; title=&quot;leetcode 1232.缀点成线&quot;&gt;&lt;/a&gt;leetcode 1232.缀点成线&lt;/h3&gt;&lt;p&gt;在一个 XY
      
    
    </summary>
    
    
      <category term="acm" scheme="http://yoursite.com/categories/acm/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
  </entry>
  
</feed>
