<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>52hertz</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-11-25T11:43:09.451Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>52hertz</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>thank you</title>
    <link href="http://yoursite.com/2019/11/25/thank-you/"/>
    <id>http://yoursite.com/2019/11/25/thank-you/</id>
    <published>2019-11-25T11:42:16.000Z</published>
    <updated>2019-11-25T11:43:09.451Z</updated>
    
    <content type="html"><![CDATA[<p>感谢腾讯爸爸，我的coding回来吧！！！！！！！！！！！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;感谢腾讯爸爸，我的coding回来吧！！！！！！！！！！！&lt;/p&gt;

      
    
    </summary>
    
    
    
      <category term="coding" scheme="http://yoursite.com/tags/coding/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode第164场周赛题解</title>
    <link href="http://yoursite.com/2019/11/24/Leetcode%E7%AC%AC164%E5%9C%BA%E5%91%A8%E8%B5%9B%E9%A2%98%E8%A7%A3/"/>
    <id>http://yoursite.com/2019/11/24/Leetcode第164场周赛题解/</id>
    <published>2019-11-24T07:55:31.000Z</published>
    <updated>2019-11-24T10:54:02.814Z</updated>
    
    <content type="html"><![CDATA[<h4 id="5271-访问所有点的最小时间"><a href="#5271-访问所有点的最小时间" class="headerlink" title="5271. 访问所有点的最小时间"></a>5271. 访问所有点的最小时间</h4><p>平面上有 n 个点，点的位置用整数坐标表示 points[i] = [xi, yi]。请你计算访问所有这些点需要的最小时间（以秒为单位）。</p><p>你可以按照下面的规则在平面上移动：</p><p>每一秒沿水平或者竖直方向移动一个单位长度，或者跨过对角线（可以看作在一秒内向水平和竖直方向各移动一个单位长度）。<br>必须按照数组中出现的顺序来访问这些点。</p><p>示例 1：</p><p><img src="/2019/11/24/Leetcode%E7%AC%AC164%E5%9C%BA%E5%91%A8%E8%B5%9B%E9%A2%98%E8%A7%A3/1.png" alt="1"></p><p>输入：points = [[1,1],[3,4],[-1,0]]<br>输出：7<br>解释：一条最佳的访问路径是： [1,1] -&gt; [2,2] -&gt; [3,3] -&gt; [3,4] -&gt; [2,3] -&gt; [1,2] -&gt; [0,1] -&gt; [-1,0]<br>从 [1,1] 到 [3,4] 需要 3 秒<br>从 [3,4] 到 [-1,0] 需要 4 秒<br>一共需要 7 秒<br>示例 2：</p><p>输入：points = [[3,2],[-2,2]]<br>输出：5</p><p>提示：</p><p>points.length == n<br>1 &lt;= n &lt;= 100<br>points[i].length == 2<br>-1000 &lt;= points[i][0], points[i][1] &lt;= 1000</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>两点之间的距离就是直角三角形直角边的较大值 代码如下： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minTimeToVisitAllPoints</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> x,y;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;p.size()<span class="number">-1</span>;i++)&#123;</span><br><span class="line">            x=<span class="built_in">abs</span>(p[i+<span class="number">1</span>][<span class="number">0</span>]-p[i][<span class="number">0</span>]);</span><br><span class="line">            y=<span class="built_in">abs</span>(p[i+<span class="number">1</span>][<span class="number">1</span>]-p[i][<span class="number">1</span>]);</span><br><span class="line">           sum=sum+max(x,y);         </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="5272-统计参与通信的服务器"><a href="#5272-统计参与通信的服务器" class="headerlink" title="5272. 统计参与通信的服务器"></a>5272. 统计参与通信的服务器</h4><p>这里有一幅服务器分布图，服务器的位置标识在 m * n 的整数矩阵网格 grid 中，1 表示单元格上有服务器，0 表示没有。</p><p>如果两台服务器位于同一行或者同一列，我们就认为它们之间可以进行通信。</p><p>请你统计并返回能够与至少一台其他服务器进行通信的服务器的数量。</p><p>示例 1：</p><p>输入：grid = [[1,0],[0,1]]<br>输出：0<br>解释：没有一台服务器能与其他服务器进行通信。</p><p><img src="/2019/11/24/Leetcode%E7%AC%AC164%E5%9C%BA%E5%91%A8%E8%B5%9B%E9%A2%98%E8%A7%A3/2.jpg" alt="1"></p><p>示例 2：</p><p>输入：grid = [[1,0],[1,1]]<br>输出：3<br>解释：所有这些服务器都至少可以与一台别的服务器进行通信。</p><p>示例 3：</p><p>输入：grid = [[1,1,0,0],[0,0,1,0],[0,0,1,0],[0,0,0,1]]<br>输出：4<br>解释：第一行的两台服务器互相通信，第三列的两台服务器互相通信，但右下角的服务器无法与其他服务器通信。</p><p>提示：</p><p>m == grid.length<br>n == grid[i].length<br>1 &lt;= m &lt;= 250<br>1 &lt;= n &lt;= 250<br>grid[i][j] == 0 or 1</p><h4 id="题解：-1"><a href="#题解：-1" class="headerlink" title="题解："></a>题解：</h4><h5 id="开两个数组维护一下当且列或当前行服务器的个数，然后遍历一下服务器，看它所在行或列有没"><a href="#开两个数组维护一下当且列或当前行服务器的个数，然后遍历一下服务器，看它所在行或列有没" class="headerlink" title="开两个数组维护一下当且列或当前行服务器的个数，然后遍历一下服务器，看它所在行或列有没"></a>开两个数组维护一下当且列或当前行服务器的个数，然后遍历一下服务器，看它所在行或列有没</h5><h5 id="有两台以上服务器即可，时间复杂度-。"><a href="#有两台以上服务器即可，时间复杂度-。" class="headerlink" title="有两台以上服务器即可，时间复杂度  。"></a>有两台以上服务器即可，时间复杂度 <img src="https://www.zhihu.com/equation?tex=O%28nm%29" alt="[公式]"> 。</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">作者：PerfectPan小明</span><br><span class="line">链接：https:<span class="comment">//zhuanlan.zhihu.com/p/93403520</span></span><br><span class="line">来源：知乎</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> col[<span class="number">300</span>],row[<span class="number">300</span>];</span><br><span class="line">    <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &gt;vec;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countServers</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(col,<span class="number">0</span>,<span class="keyword">sizeof</span>(col));</span><br><span class="line">        <span class="built_in">memset</span>(row,<span class="number">0</span>,<span class="keyword">sizeof</span>(row));</span><br><span class="line">        vec.clear();</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(<span class="keyword">int</span>)grid.size();++i)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;(<span class="keyword">int</span>)grid[i].size();++j)&#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j]==<span class="number">1</span>)&#123;</span><br><span class="line">                    vec.push_back(make_pair(i,j));</span><br><span class="line">                    col[i]++,row[j]++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(<span class="keyword">int</span>)vec.size();++i)&#123;</span><br><span class="line">            <span class="keyword">if</span> (col[vec[i].first]&gt;=<span class="number">2</span> || row[vec[i].second]&gt;=<span class="number">2</span>)&#123;</span><br><span class="line">                ans+=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;5271-访问所有点的最小时间&quot;&gt;&lt;a href=&quot;#5271-访问所有点的最小时间&quot; class=&quot;headerlink&quot; title=&quot;5271. 访问所有点的最小时间&quot;&gt;&lt;/a&gt;5271. 访问所有点的最小时间&lt;/h4&gt;&lt;p&gt;平面上有 n 个点，点的位置用整
      
    
    </summary>
    
    
      <category term="acm" scheme="http://yoursite.com/categories/acm/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>2017网易春招 消除重复元素</title>
    <link href="http://yoursite.com/2019/11/22/2017%E7%BD%91%E6%98%93%E6%98%A5%E6%8B%9B-%E6%B6%88%E9%99%A4%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/"/>
    <id>http://yoursite.com/2019/11/22/2017网易春招-消除重复元素/</id>
    <published>2019-11-22T06:22:54.000Z</published>
    <updated>2019-11-22T06:26:14.784Z</updated>
    
    <content type="html"><![CDATA[<h4 id="set的简单使用"><a href="#set的简单使用" class="headerlink" title="set的简单使用"></a>set的简单使用</h4><p>小易有一个长度为n序列，小易想移除掉里面的重复元素，但是小易想是对于每种元素保留最后出现的那个。小易遇到了困难,希望你来帮助他。<br>输入描述:<br>输入包括两行：<br>第一行为序列长度n(1 ≤ n ≤ 50)<br>第二行为n个数sequence[i](1 ≤ sequence[i] ≤ 1000)，以空格分隔</p><p>输出描述:<br>输出消除重复元素之后的序列，以空格分隔，行末无空格</p><p>输入例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">9</span><br><span class="line">100 100 100 99 99 99 100 100 100</span><br></pre></td></tr></table></figure><p>输出例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">99 100</span><br></pre></td></tr></table></figure><p>思路：从后向前去重（运用了set去重）；</p><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">1002</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v;</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;s;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.find(a[i])==s.end())&#123;</span><br><span class="line">            s.insert(a[i]);</span><br><span class="line">            v.push_back(a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;v[v.size()<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=v.size()<span class="number">-2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">" "</span>&lt;&lt;v[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;set的简单使用&quot;&gt;&lt;a href=&quot;#set的简单使用&quot; class=&quot;headerlink&quot; title=&quot;set的简单使用&quot;&gt;&lt;/a&gt;set的简单使用&lt;/h4&gt;&lt;p&gt;小易有一个长度为n序列，小易想移除掉里面的重复元素，但是小易想是对于每种元素保留最后出现的那
      
    
    </summary>
    
    
      <category term="STL" scheme="http://yoursite.com/categories/STL/"/>
    
    
      <category term="STL" scheme="http://yoursite.com/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>vmare安装Mac虚拟机</title>
    <link href="http://yoursite.com/2019/11/20/vmare%E5%AE%89%E8%A3%85Mac%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    <id>http://yoursite.com/2019/11/20/vmare安装Mac虚拟机/</id>
    <published>2019-11-20T10:51:42.000Z</published>
    <updated>2019-11-20T11:43:00.925Z</updated>
    
    <content type="html"><![CDATA[<h3 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h3><ul><li><p>WIN10</p></li><li><h5 id="VMware-Workstation-Pro-14或者15"><a href="#VMware-Workstation-Pro-14或者15" class="headerlink" title="VMware Workstation Pro 14或者15"></a>VMware Workstation Pro 14或者15</h5></li></ul><h3 id="工具准备"><a href="#工具准备" class="headerlink" title="工具准备"></a>工具准备</h3><h5 id="1-VMware-Workstation-Pro"><a href="#1-VMware-Workstation-Pro" class="headerlink" title="1.VMware Workstation Pro"></a>1.VMware Workstation Pro</h5><p>官网下载地址：<br><a href="http://download3.vmware.com/software/wkst/file/VMware-workstation-full-15.0.0-10134415.exe" target="_blank" rel="noopener">http://download3.vmware.com/software/wkst/file/VMware-workstation-full-15.0.0-10134415.exe</a><br>给几个序列号：<br>AC11H-4HZ05-08EDQ-APQGX-YCUC8<br>ZG780-8EZ9M-M89LY-M5PEG-W2AZ8<br>ZF3NU-D6XEJ-48E7Q-27YNC-PC8ED</p><h5 id="2-MacOS-Unlocker-for-VMware"><a href="#2-MacOS-Unlocker-for-VMware" class="headerlink" title="2.MacOS Unlocker for VMware"></a>2.MacOS Unlocker for VMware</h5><p>下载地址<br><a href="https://github.com/DrDonk/unlocker" target="_blank" rel="noopener">https://github.com/DrDonk/unlocker</a></p><p> <a href="https://github.com/paolo-projects/unlocker/releases" target="_blank" rel="noopener">https://github.com/paolo-projects/unlocker/releases</a> </p><p><a href="http://www.121down.com/soft/softview-43433.html" target="_blank" rel="noopener">http://www.121down.com/soft/softview-43433.html</a></p><p>应该有好用的吧！！！！</p><p>MAC OS 10.11<br>下面两个任选其一：<br><a href="http://pan.baidu.com/s/1jI78s4Y" target="_blank" rel="noopener">http://pan.baidu.com/s/1jI78s4Y</a> 密码：drbh<br><a href="https://pan.baidu.com/s/1ggZ7oFx" target="_blank" rel="noopener">https://pan.baidu.com/s/1ggZ7oFx</a> 密码: sxyj</p><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>在安装完成 VMware Workstation Pro 15 后，该软件有5个服务是自动启动的，只要你安装了，不管你有没有使用，他们都是工作的。要使用 MacOS Unlocker for VMware 对 VMware Workstation Pro 15 进行破解，就必须手动关闭这5个服务，软件无法对正在运行的文件修改。</p><h5 id="1-关闭VMware的5个自动启动服务"><a href="#1-关闭VMware的5个自动启动服务" class="headerlink" title="1.关闭VMware的5个自动启动服务"></a>1.关闭VMware的5个自动启动服务</h5><p>在计算机管理中找到服务</p><ol><li><p>双击，手动关闭这5个服务。</p><p><img src="/2019/11/20/vmare%E5%AE%89%E8%A3%85Mac%E8%99%9A%E6%8B%9F%E6%9C%BA/1.png" alt="1"></p></li><li><p>运行MacOS Unlocker for VMware运行<br>MacOS Unlocker for VMware就是MAC 补丁。按照上面的网址下载解压后如下：</p></li></ol><p><img src="/2019/11/20/vmare%E5%AE%89%E8%A3%85Mac%E8%99%9A%E6%8B%9F%E6%9C%BA/2.png" alt="1"></p><p> 右键上图文件，以管理员身份运行之 </p><p><img src="/2019/11/20/vmare%E5%AE%89%E8%A3%85Mac%E8%99%9A%E6%8B%9F%E6%9C%BA/3.png" alt="1"></p><p> 运行<strong>成功</strong>后，文件夹里文件发生了变化：多了backup和tools两个文件夹。效果如下： </p><p><img src="/2019/11/20/vmare%E5%AE%89%E8%A3%85Mac%E8%99%9A%E6%8B%9F%E6%9C%BA/4.png" alt="1"></p><p> <strong>准备工作结束了。这个tools文件夹里有我们要的东西，下面用到时再说。</strong> </p><h3 id="MAC虚拟机设置"><a href="#MAC虚拟机设置" class="headerlink" title="MAC虚拟机设置"></a>MAC虚拟机设置</h3><p><strong>出现以下的图片说明你的Mac解锁才算成功了，否则继续换工具破解虚拟机的Mac选项</strong></p><p><img src="/2019/11/20/vmare%E5%AE%89%E8%A3%85Mac%E8%99%9A%E6%8B%9F%E6%9C%BA/5.png" alt="1"></p><p><img src="/2019/11/20/vmare%E5%AE%89%E8%A3%85Mac%E8%99%9A%E6%8B%9F%E6%9C%BA/6.png" alt="1"></p><p>以上就是安装过程中需要注意的地方，其他的下一步即可。</p><h3 id="启动MAC前准备工作"><a href="#启动MAC前准备工作" class="headerlink" title="启动MAC前准备工作"></a>启动MAC前准备工作</h3><p>虚拟机安装建立后，<strong>别着急启动</strong>，还要更改这个虚拟机的配置文件。找到上图中安装虚拟机的位置，找到以”.vmx”结尾的文件，打开进行编辑。</p><p><img src="/2019/11/20/vmare%E5%AE%89%E8%A3%85Mac%E8%99%9A%E6%8B%9F%E6%9C%BA/7.png" alt="1"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在smc.present = &quot;TRUE&quot; 后面添加smc.version = &quot;0&quot;</span><br></pre></td></tr></table></figure><p> 结果如下 </p><p><img src="/2019/11/20/vmare%E5%AE%89%E8%A3%85Mac%E8%99%9A%E6%8B%9F%E6%9C%BA/8.png" alt="1"></p><p> 保存退出。 </p><h3 id="安装系统"><a href="#安装系统" class="headerlink" title="安装系统"></a>安装系统</h3><p>启动客户机，进入 MAC 系统配置界面，常规下一步操作。直到出现<strong>没有足够的可用空间来进行安装</strong>。</p><p>解决坑点</p><h5 id="1-解决安装黑苹果出现“没有符合安装资格的软件包”"><a href="#1-解决安装黑苹果出现“没有符合安装资格的软件包”" class="headerlink" title="1.解决安装黑苹果出现“没有符合安装资格的软件包”"></a>1.解决安装黑苹果出现“没有符合安装资格的软件包”</h5><h5 id="重点：因为这是最后会出现的bug，提前解决防止重启死机。"><a href="#重点：因为这是最后会出现的bug，提前解决防止重启死机。" class="headerlink" title="重点：因为这是最后会出现的bug，提前解决防止重启死机。"></a>重点：因为这是最后会出现的bug，提前解决防止重启死机。</h5><p><img src="/2019/11/20/vmare%E5%AE%89%E8%A3%85Mac%E8%99%9A%E6%8B%9F%E6%9C%BA/9.jpg" alt="1"></p><p>而其他版本却为出现此问题。后来在论坛找到了解决方法，原来是时间问题。</p><p>可能你也会遇到：在重组Mac系统时，遇到“应用程序副本不能验证 它在下载过程中可能已遭破坏或篡改”，这个是因为主板时间不正确造成，可以通过终端修改时间解决。</p><p>解决方法:</p><p>打开实用工具——终端</p><p>如果你的Mac是联网状体，可以输入一下代码：</p><p>ntpdate time.apple.com</p><p>不过安装的时候一般是没法联网的</p><p>我们只能输入：date 070512052018.03 （这里设置一个2015年以后的时间，因为10.11发布时2015年）</p><p><img src="/2019/11/20/vmare%E5%AE%89%E8%A3%85Mac%E8%99%9A%E6%8B%9F%E6%9C%BA/10.jpg" alt="1"></p><p>回车后，在终端——退出终端。</p><p>然后再进行安装就正常了。</p><h5 id="2-出现没有足够的可用空间来进行安装。"><a href="#2-出现没有足够的可用空间来进行安装。" class="headerlink" title="2.出现没有足够的可用空间来进行安装。"></a>2.出现<strong>没有足够的可用空间来进行安装</strong>。</h5><p><img src="/2019/11/20/vmare%E5%AE%89%E8%A3%85Mac%E8%99%9A%E6%8B%9F%E6%9C%BA/11.png" alt="1"></p><p> 点击屏幕上方的 “实用工具 -&gt; 磁盘工具”。选中 “ vmware workstation SATA hard drive media ”，点击 “抹掉”。</p><p><img src="/2019/11/20/vmare%E5%AE%89%E8%A3%85Mac%E8%99%9A%E6%8B%9F%E6%9C%BA/13.png" alt="1"></p><p> 退出 “磁盘工具”，再次进行安装，此时选择出现的分区。 </p><p><img src="/2019/11/20/vmare%E5%AE%89%E8%A3%85Mac%E8%99%9A%E6%8B%9F%E6%9C%BA/12.png" alt="1"></p><p> 后面都是常规化操作。 给个链接</p><p><a href="https://blog.csdn.net/weixin_43299649/article/details/82881567" target="_blank" rel="noopener">https://blog.csdn.net/weixin_43299649/article/details/82881567</a></p><h2 id="安装VMware-Tool"><a href="#安装VMware-Tool" class="headerlink" title="安装VMware Tool"></a>安装VMware Tool</h2><p>安装完成后，鼠标和窗口大小都不舒服。这时候就要安装VMware Tool。还记得MacOS Unlocker for VMware 安装后出现的两个文件夹么，其中一个tools的文件夹中有我们要的工具。</p><p><img src="/2019/11/20/vmare%E5%AE%89%E8%A3%85Mac%E8%99%9A%E6%8B%9F%E6%9C%BA/14.png" alt="1"></p><p> 加载VMware Tool </p><p><img src="/2019/11/20/vmare%E5%AE%89%E8%A3%85Mac%E8%99%9A%E6%8B%9F%E6%9C%BA/15.png" alt="1"></p><p><img src="/2019/11/20/vmare%E5%AE%89%E8%A3%85Mac%E8%99%9A%E6%8B%9F%E6%9C%BA/16.png" alt="1"></p><p><img src="/2019/11/20/vmare%E5%AE%89%E8%A3%85Mac%E8%99%9A%E6%8B%9F%E6%9C%BA/17.png" alt="1"></p><p> 设置完成后，再次右键光盘图标，点击”连接”。 </p><p><img src="/2019/11/20/vmare%E5%AE%89%E8%A3%85Mac%E8%99%9A%E6%8B%9F%E6%9C%BA/18.png" alt="1"></p><h5 id="安装VMware-Tool，重启。"><a href="#安装VMware-Tool，重启。" class="headerlink" title="安装VMware Tool，重启。"></a>安装VMware Tool，重启。</h5><p>如果VMware的服务还没有开启，这时候可以将VMware的5个服务手动启动了，怎么关闭的就怎么开启。 </p><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li>安装顺序很重要；</li><li>所有安装路径建议纯英文；</li><li>安装成功后第一时间快照一下，养成良好习惯；</li></ul><h4 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h4><p><a href="https://blog.csdn.net/zyzmzm_/article/details/82562136" target="_blank" rel="noopener">https://blog.csdn.net/zyzmzm_/article/details/82562136</a></p><p><a href="https://blog.csdn.net/longji/article/details/83280940" target="_blank" rel="noopener">https://blog.csdn.net/longji/article/details/83280940</a></p><p><a href="https://blog.csdn.net/bigbear00007/article/details/89740165" target="_blank" rel="noopener">https://blog.csdn.net/bigbear00007/article/details/89740165</a></p><p><a href="https://blog.csdn.net/weixin_43299649/article/details/82881567" target="_blank" rel="noopener">https://blog.csdn.net/weixin_43299649/article/details/82881567</a></p><p>多多百度，有耐心一定会成功！！！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;安装环境&quot;&gt;&lt;a href=&quot;#安装环境&quot; class=&quot;headerlink&quot; title=&quot;安装环境&quot;&gt;&lt;/a&gt;安装环境&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;WIN10&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;h5 id=&quot;VMware-Workstation-Pro-14
      
    
    </summary>
    
    
      <category term="Mac" scheme="http://yoursite.com/categories/Mac/"/>
    
    
      <category term="Mac" scheme="http://yoursite.com/tags/Mac/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-163周赛题解</title>
    <link href="http://yoursite.com/2019/11/17/leetcode-163%E5%91%A8%E8%B5%9B%E9%A2%98%E8%A7%A3/"/>
    <id>http://yoursite.com/2019/11/17/leetcode-163周赛题解/</id>
    <published>2019-11-17T05:47:37.000Z</published>
    <updated>2019-11-17T06:57:54.878Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h4><p><a href="https://leetcode-cn.com/contest/weekly-contest-163/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/weekly-contest-163/</a></p><h3 id="5263-二维网格迁移"><a href="#5263-二维网格迁移" class="headerlink" title="5263.二维网格迁移"></a>5263.二维网格迁移</h3><p>给你一个 <code>n</code> 行 <code>m</code> 列的二维网格 <code>grid</code> 和一个整数 <code>k</code>。你需要将 <code>grid</code> 迁移 <code>k</code> 次。</p><p>每次「迁移」操作将会引发下述活动：</p><ul><li>位于 <code>grid[i][j]</code> 的元素将会移动到 <code>grid[i][j + 1]</code>。</li><li>位于 <code>grid[i][m - 1]</code> 的元素将会移动到 <code>grid[i + 1][0]</code>。</li><li>位于 <code>grid[n - 1][m - 1]</code> 的元素将会移动到 <code>grid[0][0]</code>。</li></ul><p>请你返回 <code>k</code> 次迁移操作后最终得到的 <strong>二维网格</strong>。</p><p><strong>示例 1：</strong></p><p><img src="/2019/11/17/leetcode-163%E5%91%A8%E8%B5%9B%E9%A2%98%E8%A7%A3/1.png" alt="1"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[1,2,3],[4,5,6],[7,8,9]], k = 1</span><br><span class="line">输出：[[9,1,2],[3,4,5],[6,7,8]]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="/2019/11/17/leetcode-163%E5%91%A8%E8%B5%9B%E9%A2%98%E8%A7%A3/2.png" alt="2"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[3,8,1,9],[19,7,2,5],[4,6,11,10],[12,0,21,13]], k = 4</span><br><span class="line">输出：[[12,0,21,13],[3,8,1,9],[19,7,2,5],[4,6,11,10]]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[1,2,3],[4,5,6],[7,8,9]], k = 9</span><br><span class="line">输出：[[1,2,3],[4,5,6],[7,8,9]]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= grid.length &lt;= 50</code></li><li><code>1 &lt;= grid[i].length &lt;= 50</code></li><li><code>-1000 &lt;= grid[i][j] &lt;= 1000</code></li><li><code>0 &lt;= k &lt;= 100</code></li></ul><h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><p><strong>1.把二维网格按行优先，排列成一维数组。</strong><br>[[3,8,1,9],[19,7,2,5],[4,6,11,10],[12,0,21,13]]<br><strong>2.一维数组</strong><br>[3,8,1,9,19,7,2,5,4,6,11,10,12,0,21,13]<br><strong>3.迁移k次之后</strong><br>[12,0,21,13,3,8,1,9,19,7,2,5,4,6,11,10]<br><strong>4.这种对二维网格的迁移，实际上是把一维数组循环右移k位</strong>。</p><p><strong>5.再根据对应关系把一维数组转换为二维数组</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//对应关系:grid[i/m][i%m]=a[i];</span><br></pre></td></tr></table></figure><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; shiftGrid(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">        <span class="keyword">int</span> n=grid.size();</span><br><span class="line">        <span class="keyword">int</span> m=grid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">                </span><br><span class="line">                vec.push_back(grid[i][j]);</span><br><span class="line">            &#125;     </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> l=vec.size();</span><br><span class="line">        <span class="keyword">int</span> a[l+<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;l;i++)&#123;</span><br><span class="line">            a[(i+k)%l]=vec[i];</span><br><span class="line">            <span class="comment">//cout&lt;&lt;a[i]&lt;&lt;endl;</span></span><br><span class="line">        &#125;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;l;i++)&#123;</span><br><span class="line">            grid[i/m][i%m]=a[i];</span><br><span class="line">       &#125;</span><br><span class="line">    <span class="keyword">return</span> grid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>高效代码</strong></p><p> <strong>可以把这个二维数组想像成一个n*m的环,推进k次就是把环的起点后移k位</strong> </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; shiftGrid(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res(grid.size(), <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(grid[<span class="number">0</span>].size()));</span><br><span class="line">        <span class="keyword">int</span> tmp;</span><br><span class="line">        <span class="keyword">int</span> c, r;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].size(); ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                tmp = i * grid[<span class="number">0</span>].size() + j + k;</span><br><span class="line">                r = (tmp  / grid[<span class="number">0</span>].size()) % grid.size();</span><br><span class="line">                c = tmp % grid[<span class="number">0</span>].size();</span><br><span class="line">                res[r][c] = grid[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="5264-在受污染的二叉树中查找元素"><a href="#5264-在受污染的二叉树中查找元素" class="headerlink" title="5264.在受污染的二叉树中查找元素"></a>5264.在受污染的二叉树中查找元素</h3><p>给出一个满足下述规则的二叉树：</p><ol><li><code>root.val == 0</code></li><li>如果 <code>treeNode.val == x</code> 且 <code>treeNode.left != null</code>，那么 <code>treeNode.left.val == 2 * x + 1</code></li><li>如果 <code>treeNode.val == x</code> 且 <code>treeNode.right != null</code>，那么 <code>treeNode.right.val == 2 * x + 2</code></li></ol><p>现在这个二叉树受到「污染」，所有的 <code>treeNode.val</code> 都变成了 <code>-1</code>。</p><p>请你先还原二叉树，然后实现 <code>FindElements</code> 类：</p><ul><li><code>FindElements(TreeNode* root)</code> 用受污染的二叉树初始化对象，你需要先把它还原。</li><li><code>bool find(int target)</code> 判断目标值 <code>target</code> 是否存在于还原后的二叉树中并返回结果。</li></ul><p><strong>示例 1：</strong></p><p><strong><img src="/2019/11/17/leetcode-163%E5%91%A8%E8%B5%9B%E9%A2%98%E8%A7%A3/3.jpg" alt="3"></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;FindElements&quot;,&quot;find&quot;,&quot;find&quot;]</span><br><span class="line">[[[-1,null,-1]],[1],[2]]</span><br><span class="line">输出：</span><br><span class="line">[null,false,true]</span><br><span class="line">解释：</span><br><span class="line">FindElements findElements = new FindElements([-1,null,-1]); </span><br><span class="line">findElements.find(1); // return False </span><br><span class="line">findElements.find(2); // return True</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><strong><img src="/2019/11/17/leetcode-163%E5%91%A8%E8%B5%9B%E9%A2%98%E8%A7%A3/4.jpg" alt="4"></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;FindElements&quot;,&quot;find&quot;,&quot;find&quot;,&quot;find&quot;]</span><br><span class="line">[[[-1,-1,-1,-1,-1]],[1],[3],[5]]</span><br><span class="line">输出：</span><br><span class="line">[null,true,true,false]</span><br><span class="line">解释：</span><br><span class="line">FindElements findElements = new FindElements([-1,-1,-1,-1,-1]);</span><br><span class="line">findElements.find(1); // return True</span><br><span class="line">findElements.find(3); // return True</span><br><span class="line">findElements.find(5); // return False</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><p><strong><img src="/2019/11/17/leetcode-163%E5%91%A8%E8%B5%9B%E9%A2%98%E8%A7%A3/5.jpg" alt="5"></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;FindElements&quot;,&quot;find&quot;,&quot;find&quot;,&quot;find&quot;,&quot;find&quot;]</span><br><span class="line">[[[-1,null,-1,-1,null,-1]],[2],[3],[4],[5]]</span><br><span class="line">输出：</span><br><span class="line">[null,true,false,false,true]</span><br><span class="line">解释：</span><br><span class="line">FindElements findElements = new FindElements([-1,null,-1,-1,null,-1]);</span><br><span class="line">findElements.find(2); // return True</span><br><span class="line">findElements.find(3); // return False</span><br><span class="line">findElements.find(4); // return False</span><br><span class="line">findElements.find(5); // return True</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><p><code>TreeNode.val == -1</code></p></li><li><p>二叉树的高度不超过 <code>20</code></p></li><li><p>节点的总数在 <code>[1, 10^4]</code> 之间</p></li><li><p>调用 <code>find()</code> 的总次数在 <code>[1, 10^4]</code> 之间</p></li><li><p><code>0 &lt;= target &lt;= 10^6</code></p><h4 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h4></li></ul>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FindElements</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt;hash;</span><br><span class="line">FindElements(TreeNode* root) &#123;</span><br><span class="line">root-&gt;val = <span class="number">0</span>;</span><br><span class="line">restore(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (hash.count(target))<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">restore</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root) &#123;</span><br><span class="line">hash.insert(root-&gt;val);</span><br><span class="line"><span class="keyword">if</span> (root-&gt;left) &#123;</span><br><span class="line">root-&gt;left-&gt;val = (root-&gt;val &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">restore(root-&gt;left);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (root-&gt;right) &#123;</span><br><span class="line">root-&gt;right-&gt;val = (root-&gt;val &lt;&lt; <span class="number">1</span>) + <span class="number">2</span>;</span><br><span class="line">restore(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>  给本题里未受污染的二叉树节点值加一，它的值就类似于满二叉树节点间的关系。</p><pre><code>0                  1</code></pre><p>   1 2     会变为      2 3<br>  3 4                4 5<br>  每个节点的值为 x, 左孩子值为 2x，右孩子值为 2x + 1。</p><p>  深度优先遍历二叉树，填入对应的值。</p><p>  并把值存入哈希表中，查询时直接返回。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FindElements</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    FindElements(TreeNode* root) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root) dfs(root, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s.count(target);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="keyword">const</span> <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        root-&gt;val = val - <span class="number">1</span>;</span><br><span class="line">        s.insert(root-&gt;val);</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left) dfs(root-&gt;left, <span class="number">2</span> * val);</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;right) dfs(root-&gt;right, <span class="number">2</span> * val + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your FindElements object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * FindElements* obj = new FindElements(root);</span></span><br><span class="line"><span class="comment"> * bool param_1 = obj-&gt;find(target);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h3 id="5265-可被三整除的最大和"><a href="#5265-可被三整除的最大和" class="headerlink" title="5265.可被三整除的最大和"></a>5265.可被三整除的最大和</h3><p>给你一个整数数组 nums，请你找出并返回能被三整除的元素最大和。</p><p>示例 1：</p><p>输入：nums = [3,6,5,1,8]<br>输出：18<br>解释：选出数字 3, 6, 1 和 8，它们的和是 18（可被 3 整除的最大和）。<br>示例 2：</p><p>输入：nums = [4]<br>输出：0<br>解释：4 不能被 3 整除，所以无法选出数字，返回 0。<br>示例 3：</p><p>输入：nums = [1,2,3,4,4]<br>输出：12<br>解释：选出数字 1, 3, 4 以及 4，它们的和是 12（可被 3 整除的最大和）。</p><p>提示：</p><p>1 &lt;= nums.length &lt;= 4 * 10^4<br>1 &lt;= nums[i] &lt;= 10^4</p><h4 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h4><p>思路：求出数组和sum，如果sum%3==1 那么答案就是sum减去两个模3=2的或者一个模3=1的。如果sum%3==2 那么答案就是sum减去两个模1的或者一个模2的数字。统计数组里面模2 和模1的，找到最小值，最后两种可能都试一下就可以了。</p><p>为了省时间我用的排序，其实不用排序也可以，O(n)找最小即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v1,v2;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSumDivThree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x:nums)</span><br><span class="line">        &#123;</span><br><span class="line">            sum+=x;</span><br><span class="line">            <span class="keyword">if</span>(x%<span class="number">3</span>==<span class="number">1</span>)v1.push_back(x);</span><br><span class="line">            <span class="keyword">if</span>(x%<span class="number">3</span>==<span class="number">2</span>)v2.push_back(x);</span><br><span class="line">        &#125;</span><br><span class="line">        sort(v1.begin(),v1.end());</span><br><span class="line">        sort(v2.begin(),v2.end());</span><br><span class="line">        <span class="keyword">if</span>(sum%<span class="number">3</span>==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = <span class="number">1e9</span>;</span><br><span class="line">            <span class="keyword">if</span>(v1.size())tmp = v1[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">if</span>(v2.size()&gt;=<span class="number">2</span>)tmp=min(tmp,v2[<span class="number">0</span>]+v2[<span class="number">1</span>]);</span><br><span class="line">            sum-=tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(sum%<span class="number">3</span>==<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = <span class="number">1e9</span>;</span><br><span class="line">            <span class="keyword">if</span>(v2.size())tmp = v2[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">if</span>(v1.size()&gt;=<span class="number">2</span>)tmp=min(tmp,v1[<span class="number">0</span>]+v1[<span class="number">1</span>]);</span><br><span class="line">            sum-=tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;题目链接&quot;&gt;&lt;a href=&quot;#题目链接&quot; class=&quot;headerlink&quot; title=&quot;题目链接&quot;&gt;&lt;/a&gt;题目链接&lt;/h4&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/contest/weekly-contest-163/&quot; 
      
    
    </summary>
    
    
      <category term="acm" scheme="http://yoursite.com/categories/acm/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>hexo本地博客转移</title>
    <link href="http://yoursite.com/2019/11/16/hexo%E6%9C%AC%E5%9C%B0%E5%8D%9A%E5%AE%A2%E8%BD%AC%E7%A7%BB/"/>
    <id>http://yoursite.com/2019/11/16/hexo本地博客转移/</id>
    <published>2019-11-16T03:07:54.000Z</published>
    <updated>2019-11-16T03:19:03.348Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-复制配置文件"><a href="#1-复制配置文件" class="headerlink" title="1. 复制配置文件"></a>1. 复制配置文件</h4><p>将原来的配置文件进行备份，只需要将文件夹 source、themes和配置文件_config.yml备份即可。</p><p><img src="/2019/11/16/hexo%E6%9C%AC%E5%9C%B0%E5%8D%9A%E5%AE%A2%E8%BD%AC%E7%A7%BB/1.png" alt="1"></p><h4 id="2-安装Node-js"><a href="#2-安装Node-js" class="headerlink" title="2.安装Node.js"></a>2.安装Node.js</h4><p>sudo apt-get install nodejs<br>sudo apt-get install npm</p><h4 id="3-安装hexo"><a href="#3-安装hexo" class="headerlink" title="3.安装hexo"></a>3.安装hexo</h4><p>sudo npm install -g hexo</p><h4 id="4-新建文件夹，cd进入"><a href="#4-新建文件夹，cd进入" class="headerlink" title="4.新建文件夹，cd进入"></a>4.新建文件夹，cd进入</h4><p>hexo init<br>使用hexo s查看是否能使用。</p><h4 id="5-将备份的文件覆盖到现在的文件夹"><a href="#5-将备份的文件覆盖到现在的文件夹" class="headerlink" title="5.将备份的文件覆盖到现在的文件夹"></a>5.将备份的文件覆盖到现在的文件夹</h4><p>现在使用hexo s查看是否已经成功。</p><p>此时，所有工作已经完成。</p><h3 id="最安全的hexo多台电脑同步博客解决方案–非新建分支"><a href="#最安全的hexo多台电脑同步博客解决方案–非新建分支" class="headerlink" title="最安全的hexo多台电脑同步博客解决方案–非新建分支"></a>最安全的hexo多台电脑同步博客解决方案–非新建分支</h3><p>我们经常有这样一个需求场景：需要在多台电脑间完成 Hexo 博客的撰写和发布，这就涉及到如何多台电脑同步博客的问题。</p><p><strong>我最近也遇到了这个问题，网上看了很多方案。目前网上大部分 hexo 多电脑同步博客方案都是新建一个开源分支去存放博客源文件，但是你会发现，这样做的话很多第三插件配置的appid、app_key等密钥信息也暴露在了公开的仓库里，存在一定的数据安全隐患。</strong></p><p><strong>那有没有什么办法不暴露这些信息呢？对了，用一个私有仓库来存放博客源文件不就结了嘛。虽然 Github 的私有仓库是收费的，但是我的博客是同时部署在 Github 和 Coding 的，而 Coding 是可以新建私有仓库的。Nice，完美解决。</strong></p><p>当我准备写遍博客来分享（xuan yao）想到的这个解决方案时，最后还是荣幸的发现一遍文章已经分享了这个方案，只是在搜索引擎中不太好搜出来。本着“不重复造轮子的原则”，笔者就不重写了，而且他已经写的很好了。但是有几个问题需要特别注意一下：</p><ol><li><p>该文中删除主题的 .git 配置，如果你有多个主题文件夹的话，需要都删除(如 NexT 主题)。然后删除的命令那位笔者不小心写错了，应该是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf ./themes/next/.git/</span><br></pre></td></tr></table></figure><p>用这条命令来删除你对应主题文件夹里的.git 文件夹，注意 .git 是一个隐藏文件夹。</p></li><li><p><code>.gitignore</code> 文件夹在 Hexo 的根目录下可能已经存在了，可以打开和该文中的忽略事项比对一下，如果一样，接着 <code>git init</code> 初始化 git 仓库就好；如果没有该 <code>.gitignore</code> 文件夹就新建一个添加相应忽略事项再 <code>git init</code> 初始化。</p></li><li><p><strong>这点需要特别注意，否则可能导致迁移失败：</strong><br>虽然我们第 1 步中删除了主题的 .git 配置，第 2 步中Hexo项目根目录的 <code>.gitignore</code> 文件也并没有忽略掉 <code>theme</code> 这个文件夹。<strong>但是！！</strong> NexT 主题的文件夹原来是用 git 来管理的，里面还有一个 <code>.gitignore</code> 文件，把 <code>themes/next/source/lib</code> 目录下的很多文件给忽略掉了。</p><p>这就导致了你上传到私有仓库时，你以为你把 <code>themes</code> 文件下的所有内容都上传到仓库了，但其实 “偷偷”的把 <code>themes/next/source/lib</code> 目录下的很多必要的文件也忽略掉了，并没有上传。然后在新电脑上拉下来的时候，<code>hexo g</code>、<code>hexo s</code> 一预览，你会奇怪的发现：<strong>所有的 FontAwesome 相关的图标都不见了，其他的功能一切正常。</strong></p><p><strong>正确的做法是</strong>：在新机器上把私有仓库上的博客源文件 clone 下来后，因为还缺点原来的文件，所以应该去原来机器上 <code>themes/next/source/lib</code> 目录下，把整个 lib 目录下的文件全部复制粘贴到新机器对应的 <code>themes/next/source/lib</code> 目录下，这样就能正常生成站点文件了。</p><blockquote><p>注意：同理，如果你的 <code>themes</code> 目录下有多个主题配置文件的话，可以查看是否有 <code>.gitignore</code> 文件，用 git 上传私有仓库时是否也忽略了一些必要资源，如果有再新电脑上对应复制过来就 OK 了。</p></blockquote><p>关于这个问题的详情，可以看这：<a href="https://github.com/theme-next/hexo-theme-next/issues/564#issuecomment-451385682" target="_blank" rel="noopener">https://github.com/theme-next/hexo-theme-next/issues/564#issuecomment-451385682</a></p></li><li><p>在新电脑上 <code>npm install</code> 下载 hexo 所需的环境的时候，要切到 hexo 的根目录下，再执行 <code>npm install</code>。</p></li><li><p>当你在新电脑用 <code>npm install</code> 下载依赖的第三插件时，由于 node 的版本、众多第三方插件、跨平台等原因，可能有的插件会存在兼容性问题，导致下载不下来，笔者想迁移到 Mac 上就遇到兼容性问题了，<code>fsevent</code> 插件目前不支持 node v11+ 版本，而刚配置新电脑的 node 环境时，默认安装的是最新版的 node，需要降低 node 的版本才能下载成功。</p><p><a href="https://www.alankeene.com/2019/0102/fsevents-didnot-soppurt-node11.html" target="_blank" rel="noopener">node 11 无法安装 fsevents 插件的解决方案</a></p><p>至于如何降低 node 的版本，其实你不用删除，有一个叫 <code>nvm</code> （Node Version Manager）的工具，专门用来管理多个版本的 node 环境的，你可以下载多个版本的 node 存在你的机器中，用 <code>nvm</code> 的命令行就可以实现不同版本 node 环境的随意切换，非常方便。</p><p><a href="https://github.com/creationix/nvm" target="_blank" rel="noopener">这是 nvm 的 github 地址</a></p></li><li><p>好，当你在新的电脑上写完博客，本地预览也没问题，准备用 hexo d 部署到 Github 和 Coding 上前，别忘了把新电脑的 SSH 公钥配置到 Github 和 Coding 上。</p><p>然后用 hexo d部署时，由于在新机器上，SSH 密钥和之前的不一样，第一次尝试连接 Github 主机时会提示：<br><code>The authenticity of host &#39;github.com&#39; can&#39;t be established.</code><br><code>Are you sure you want continue connecting?</code></p><p>输入 yes 就好，同理 coding 仓库也会提示，同样输入yes。至此，新电脑上写完的博客也成功同步更新到 Github 和 Coding 的仓库上了。</p><p>更新完博客后，记得 用 git push 将新电脑上改动的博客源文件也 push 到私有仓库中，实现博客源文件的同步更新。</p></li><li><p>当你在另一台电脑上准备开始写博客前，记得把远程私有仓库的最新博客源文件拉到本地，<strong>但记得不要用 <code>git pull</code> 的方式</strong>，用如下两条命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//将远程 git 仓库上最新的内容拉取到本地，将本地库所关联的远程库更新至最新</span><br><span class="line">git fetch --all</span><br><span class="line">//强制将本地库的内容指向最新远程仓库的master分支   </span><br><span class="line">git reset --hard origin/master</span><br></pre></td></tr></table></figure></li></ol><p>最后附上该篇博客的地址：</p><ul><li><a href="https://ricky.moe/2017/01/13/hexo-perfect-synchronize/" target="_blank" rel="noopener">最完美的Hexo多电脑同步方法</a></li></ul><p>从此，你就可以在多台电脑间愉快地同步更新博客啦～<br>若到一台新的电脑上，只要把博客源码 clone 下来，配置好新机器的 <code>node</code>、<code>hexo</code>、<code>git</code> 环境，随时可以发车～</p><p><strong><code>2019.1.8 最新更新：</code> 好消息是：Github 从 2019.1.8 日起可以免费使用私有仓库了，那大家也可以选择把博客源文件传到 Github 私有仓库上，维护起来更加方便了。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1-复制配置文件&quot;&gt;&lt;a href=&quot;#1-复制配置文件&quot; class=&quot;headerlink&quot; title=&quot;1. 复制配置文件&quot;&gt;&lt;/a&gt;1. 复制配置文件&lt;/h4&gt;&lt;p&gt;将原来的配置文件进行备份，只需要将文件夹 source、themes和配置文件_conf
      
    
    </summary>
    
    
      <category term="hexo" scheme="http://yoursite.com/categories/hexo/"/>
    
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>linux安装包的区别</title>
    <link href="http://yoursite.com/2019/11/16/linux%E5%AE%89%E8%A3%85%E5%8C%85%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2019/11/16/linux安装包的区别/</id>
    <published>2019-11-16T03:00:01.000Z</published>
    <updated>2019-11-16T03:05:31.885Z</updated>
    
    <content type="html"><![CDATA[<h4 id="deb、rpm、tar-gz三种Linux软件包的区别"><a href="#deb、rpm、tar-gz三种Linux软件包的区别" class="headerlink" title="deb、rpm、tar.gz三种Linux软件包的区别"></a>deb、rpm、tar.gz三种Linux软件包的区别</h4><p>接解LINUX的，同样都是for linux，但rpm、tar.gz、deb包还是有很大区别的，</p><p>这种区别可使安装过程进行不下去。那我们应该下载什么格式的包呢？</p><p>**rpm包-在红帽LINUX、SUSE、Fedora可以直接进行安装，但在Ubuntu中却无法识别；</p><p>deb包-是Ubuntu的专利，在Ubuntu中双击deb包就可以进入自动安装进程；</p><p> tar.gz包-在所有的Linux版本中都能使用，但安装过程也最麻烦。 </p><p>​     要先解压缩，然后在“终端”里用cd命令进入刚才解压的目录，再找到安装链接文件安装。</p><p>   比如tar.gz包解压到了“/temp/*****.tar.gz/”，tar.gz包中的安装链接文件为install：</p><p>​     1- cd/temp/*****.tar.gz/</p><p>​     2- ./install</p><p>​     3- 根据提示输入“ENTER”或“安装目录”</p><p>​     4- 结束</p><h4 id="tar-gz和-zip文件的区别"><a href="#tar-gz和-zip文件的区别" class="headerlink" title=".tar.gz和.zip文件的区别"></a>.tar.gz和.zip文件的区别</h4><p>在一开始下载数据集的时候遇到的疑惑</p><p>他们的不同点在于：</p><p>1 .tar.gz文件一般用于Linux系统上，而.zip文件一般流行于Windows系统上</p><p>2 .tar.gz格式的文件比.zip文件要小很多</p><p>虽然这两种格式的文件有许多不同，但他们都是压缩文件，且文件里包含的内容相同，在windows系统中WinRar等工具同样可以解压缩tar.gz格式的</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;deb、rpm、tar-gz三种Linux软件包的区别&quot;&gt;&lt;a href=&quot;#deb、rpm、tar-gz三种Linux软件包的区别&quot; class=&quot;headerlink&quot; title=&quot;deb、rpm、tar.gz三种Linux软件包的区别&quot;&gt;&lt;/a&gt;deb、r
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu如何卸载软件</title>
    <link href="http://yoursite.com/2019/11/16/ubuntu%E5%A6%82%E4%BD%95%E5%8D%B8%E8%BD%BD%E8%BD%AF%E4%BB%B6/"/>
    <id>http://yoursite.com/2019/11/16/ubuntu如何卸载软件/</id>
    <published>2019-11-16T02:27:01.000Z</published>
    <updated>2019-11-16T02:53:59.505Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-使用Synaptic软件包管理器进行卸载"><a href="#1-使用Synaptic软件包管理器进行卸载" class="headerlink" title="1.使用Synaptic软件包管理器进行卸载"></a>1.使用Synaptic软件包管理器进行卸载</h4><p>打开软件包管理器。Ubuntu自带了一个GUI（Graphical User Interface，图形化用户界面）软件包管理器，它可 以让你在一个可视化窗口中卸载程序。如果你不习惯使用命令行，这一工具将非常有用。</p><p>点击系统，然后选择管理。在管理菜单中，选择Synaptic软件包管理器。<br>如果你使用Unity，可以打开dashboard并搜索“Synaptic”</p><p> 某些较新版本的Ubuntu没有预装Synaptic。要安装它，打开终端并输入：    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install synaptic</span><br></pre></td></tr></table></figure><h4 id="2-使用软件中心进行卸载"><a href="#2-使用软件中心进行卸载" class="headerlink" title="2.使用软件中心进行卸载"></a>2.使用软件中心进行卸载</h4><p> 打开软件中心。软件中心是一个可以安装和卸载Linux软件的GUI软件包管理器。在较旧版本的Ubuntu上，软件中心位于应用程序菜单内。在较近期的版本中，你可以再Launcher内找到软件中心，或者在Dash搜索栏中搜索“software”。 2 打开已安装的软件。在左边窗格内，点击已安装软件链接。这将打开所有已安装在你的系统上的软件列表。 3 卸载程序。选中需要卸载的程序并点击工具栏上的移除按钮。你可能会被要求输入管理员密码。输入密码后，程序将被自动移除。    你可以选择多个程序把它们添加到移除队列，然后点击移除按钮。当第一个程序完成卸载后，将开始对队列中下一个程序进行卸载。 </p><p>注：纯复制，因为基本不用</p><h4 id="3-使用终端进行卸载"><a href="#3-使用终端进行卸载" class="headerlink" title="3.使用终端进行卸载"></a>3.使用终端进行卸载</h4><p> 1.打开一个终端，输入<code>dpkg --list</code> ,按下Enter键，终端输出以下内容，显示的是你电脑上安装的所有软件。  </p><p> 2.在终端中找到你需要卸载的软件的名称，列表是按照首字母排序的。  </p><p>3.在终端上输入命令sudo apt-get –purge remove 包名（–purge是可选项，写上这个属性是将软件及其配置文件一并删除，如不需要删除配置文件，可执行sudo apt-get remove 包名） ，此处我要删除的是polipo ，那么在终端输入sudo apt-get –purge remove polipo，按下回车，输入密码，再次回车。 </p><p> 4.执行过程中，会提示你是否真的要删除（继续执行删除命令），在终端输入<code>y</code> ，然后回车，删除程序继续执行。  </p><p> 5.正常情况下，再次出现输入命令行删除成功。</p><h4 id="4-卸载源代码编译的的软件："><a href="#4-卸载源代码编译的的软件：" class="headerlink" title="4.卸载源代码编译的的软件："></a>4.卸载源代码编译的的软件：</h4><p>cd 源代码目录<br>make clean<br>./configure<br>（make）<br>make uninstall<br>rm -rf 目录</p><h4 id="5-清理系统："><a href="#5-清理系统：" class="headerlink" title="5.清理系统："></a>5.<strong>清理系统：</strong></h4><p>sudo apt-get autoclean<br>sudo apt-get clean<br>sudo apt-get autoremove<br>（或使用ubuntu-tweak清理）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1-使用Synaptic软件包管理器进行卸载&quot;&gt;&lt;a href=&quot;#1-使用Synaptic软件包管理器进行卸载&quot; class=&quot;headerlink&quot; title=&quot;1.使用Synaptic软件包管理器进行卸载&quot;&gt;&lt;/a&gt;1.使用Synaptic软件包管理器进行
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>用文字替换网页链接</title>
    <link href="http://yoursite.com/2019/11/15/%E7%94%A8%E6%96%87%E5%AD%97%E6%9B%BF%E6%8D%A2%E7%BD%91%E9%A1%B5%E9%93%BE%E6%8E%A5/"/>
    <id>http://yoursite.com/2019/11/15/用文字替换网页链接/</id>
    <published>2019-11-15T10:58:26.000Z</published>
    <updated>2019-11-15T11:01:18.682Z</updated>
    
    <content type="html"><![CDATA[<h3 id="怎么把一个网址链接转换成文字的形式，-就是点一下那段文字就进入该网站"><a href="#怎么把一个网址链接转换成文字的形式，-就是点一下那段文字就进入该网站" class="headerlink" title="怎么把一个网址链接转换成文字的形式， 就是点一下那段文字就进入该网站"></a>怎么把一个网址链接转换成文字的形式， 就是点一下那段文字就进入该网站</h3><p>何把一个网址链接转换成文字的形式，点击一下那个文字，就可以进入该网站了？</p><p>我今天上午试做了，现在跟有需求但不会操作的朋友们分享一下：<br>我是在MarkDown编辑器上完成的，先打开MarkDown编辑器，然后按照下面的程序编写就是了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a  href =&quot;完整的地址链接&quot;&gt;代替的文字 &lt;/a&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;怎么把一个网址链接转换成文字的形式，-就是点一下那段文字就进入该网站&quot;&gt;&lt;a href=&quot;#怎么把一个网址链接转换成文字的形式，-就是点一下那段文字就进入该网站&quot; class=&quot;headerlink&quot; title=&quot;怎么把一个网址链接转换成文字的形式， 就是点一下
      
    
    </summary>
    
    
      <category term="hexo" scheme="http://yoursite.com/categories/hexo/"/>
    
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu下安装程序的三种方法</title>
    <link href="http://yoursite.com/2019/11/15/Ubuntu%E4%B8%8B%E5%AE%89%E8%A3%85%E7%A8%8B%E5%BA%8F%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2019/11/15/Ubuntu下安装程序的三种方法/</id>
    <published>2019-11-15T09:48:06.000Z</published>
    <updated>2019-11-16T02:55:57.854Z</updated>
    
    <content type="html"><![CDATA[<h3 id="UBUNTU下安装程序的三种方法"><a href="#UBUNTU下安装程序的三种方法" class="headerlink" title="UBUNTU下安装程序的三种方法"></a>UBUNTU下安装程序的三种方法</h3><p>在ubuntu当中，安装应用程序我所知道的有三种方法，分别是apt-get，dpkg安装deb和make install安装源码包三种。下面针对每一种方法各举例来说明。</p><h4 id="1-apt-get方法"><a href="#1-apt-get方法" class="headerlink" title="(1)apt-get方法"></a>(1)apt-get方法</h4><p>使用apt-get install来安装应用程序算是最常见的一种安装方法了，比如我要安装build-essential这个软件，使用以下，他会帮我把所有的依赖包都一起安装了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install 软件名</span><br></pre></td></tr></table></figure><p>执行上述命令以后，我们可以看到一下信息，The following extra packages will be installed:表示所有需要再安装的依赖包。</p><p>下面给出apt-get的的各种参数：</p><p>apt-get install xxx 安装xxx  。如果带有参数，那么-d 表示仅下载 ，-f 表示强制安装<br>apt-get remove xxx 卸载xxx<br>apt-get update 更新软件信息数据库<br>apt-get upgrade 进行系统升级<br>apt-cache search 搜索软件包<br>Tips：建议您经常使用“apt-get update”命令来更新您的软件信息数据库 </p><p>apt-get理论上是要求能够联网，但是如果制作了本地源，就不需要联网，制作本地源可以参考：<a href="http://www.cnblogs.com/xwdreamer/p/3875857.html" target="_blank" rel="noopener">ubuntu制作本地源</a></p><h4 id="2-dpkg安装deb包"><a href="#2-dpkg安装deb包" class="headerlink" title="(2)dpkg安装deb包"></a>(2)dpkg安装deb包</h4><p>Ubuntu软件包格式为deb，安装方法如下：</p><p>  sudo dpkg -i package.deb</p><p>dpkg的详细使用方法，网上有很多，下面简单列了几个：</p><p>dpkg -i package.deb安装包</p><p>dpkg -r package删除包</p><p>dpkg -P package删除包（包括配置文件）</p><p>dpkg -L package列出与该包关联的文件</p><p>dpkg -l package显示该包的版本</p><p>dpkg –unpack package.deb解开 deb 包的内容</p><p>dpkg -S keyword搜索所属的包内容</p><p>dpkg -l列出当前已安装的包</p><p>dpkg -c package.deb列出 deb 包的内容</p><p>dpkg –configure package配置包</p><h4 id="make-install源代码安装"><a href="#make-install源代码安装" class="headerlink" title="make install源代码安装"></a>make install源代码安装</h4><p>如果要使用make安装的话，那么必须得安装build-essential这个依赖包，安装方法已经在前面说过了。在安装完毕以后，我们就可以进行源码安装。源码安装大致可以分为三步骤：（./configure）–＞ 编译（sudo make） –＞ 安装（sudo make install）。</p><ol><li>配置：这是编译源代码的第一步，通过 <code>./configure</code> 命令完成。执行此步以便为编译源代码作准备。常用的选项有 <code>--</code>prefix=PREFIX，用以指定程序的安装位置。更多的选项可通过 <code>--</code>help 查询。也有某些程序无需执行此步。</li><li>编译：一旦配置通过，可即刻使用 <code>make</code> 指令来执行源代码的编译过程。视软件的具体情况而定，编译所需的时间也各有差异，我们所要做的就是耐心等候和静观其变。此步虽然仅下简单的指令，但有时候所遇到的问题却十分复杂。较常碰到的情形是程序编译到中途却无法圆满结束。此时，需要根据出错提示分析以便找到应对之策。</li><li>安装：如果编译没有问题，那么执行 <code>sudo make install</code> 就可以将程序安装到系统中了。</li></ol><p>下面以安装nagios为例进行说明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//1.解压缩</span><br><span class="line">tar -zxf nagios-4.0.2.tar.gz  </span><br><span class="line">//2.进入目录</span><br><span class="line">cd nagios-4.0.2</span><br><span class="line">//3.配置</span><br><span class="line">./configure --prefix=/usr/local/nagios     </span><br><span class="line">//4.编译</span><br><span class="line">make all</span><br><span class="line">//5.安装</span><br><span class="line">make install &amp;&amp; make install-init &amp;&amp; make install-commandmode &amp;&amp; make install-config</span><br></pre></td></tr></table></figure><h3 id="ubuntu制作本地源"><a href="#ubuntu制作本地源" class="headerlink" title="ubuntu制作本地源"></a>ubuntu制作本地源</h3><h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>平时apt-get install安装软件时，下载的deb文件都会存放在/var/cache/apt/archives/下，为了今后重装或给别人用，特别是没有网络时，这些deb文件实际上是可以派上用途的，也就是可以用这些deb制作成本地源。这种方法还有一个应用场景：</p><ol><li>先在有网络的服务器上面进行apt-get install安装</li><li>然后制作本地源</li><li>将本地源拷贝到没有网络的服务器上，然后在那台机器上设定sourcelist指向这个本地源，此时在那台没有网络的服务器上也可以执行apt-get install安装了。</li></ol><p>下面给出可行且实用的部分本地源制作步骤：</p><p>一、在自己的根目录下建立一个目录，用于放所有下载的软件包，目录名随自己喜欢,建议新手在自己的根目录下进行以下操作，以避免操作权限问题的困扰。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir ~/ packs</span><br></pre></td></tr></table></figure><p>拷贝过来发现在packs当中为文件都是root账户的，需要修改</p><p>修改所有者</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chown -R enadmin.enadmin *</span><br></pre></td></tr></table></figure><p> 修改权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod ug+rw,o+r *</span><br></pre></td></tr></table></figure><p>二、复制文件到packs文件夹下，目录依各人情况变化。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo cp /var/cache/apt/archives/* ~/packs -r</span><br></pre></td></tr></table></figure><p>三、建立Packages.gz包，里面记录了packs文件夹下面的软件包信息，包括依赖信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpkg-scanpackages packs /dev/null |gzip &gt; packs/Packages.gz -r</span><br></pre></td></tr></table></figure><p> 完成此操作后，将packs文件夹复制到一个不常格式化的分区中，作为长久使用，比如我将它放在一个fat32的分区时面，路径是 /media/packs</p><p>四、加本地源</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gedit /etc/apt/sources.list</span><br></pre></td></tr></table></figure><p>添加以下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deb file:///media/ packs/</span><br></pre></td></tr></table></figure><p>注意packs后面有一个斜杠，前面还要有空格</p><p>五、更新源</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;UBUNTU下安装程序的三种方法&quot;&gt;&lt;a href=&quot;#UBUNTU下安装程序的三种方法&quot; class=&quot;headerlink&quot; title=&quot;UBUNTU下安装程序的三种方法&quot;&gt;&lt;/a&gt;UBUNTU下安装程序的三种方法&lt;/h3&gt;&lt;p&gt;在ubuntu当中，安装应用
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>字符串匹配</title>
    <link href="http://yoursite.com/2019/11/12/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/"/>
    <id>http://yoursite.com/2019/11/12/字符串匹配/</id>
    <published>2019-11-12T06:01:58.000Z</published>
    <updated>2019-11-12T06:01:58.058Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>线段树</title>
    <link href="http://yoursite.com/2019/11/12/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    <id>http://yoursite.com/2019/11/12/线段树/</id>
    <published>2019-11-12T06:01:46.000Z</published>
    <updated>2019-11-12T06:01:46.511Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>数论</title>
    <link href="http://yoursite.com/2019/11/12/%E6%95%B0%E8%AE%BA/"/>
    <id>http://yoursite.com/2019/11/12/数论/</id>
    <published>2019-11-12T06:00:26.000Z</published>
    <updated>2019-11-12T06:00:26.654Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>拓扑排序</title>
    <link href="http://yoursite.com/2019/11/12/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2019/11/12/拓扑排序/</id>
    <published>2019-11-12T06:00:13.000Z</published>
    <updated>2019-11-12T06:00:13.893Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>并查集</title>
    <link href="http://yoursite.com/2019/11/12/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <id>http://yoursite.com/2019/11/12/并查集/</id>
    <published>2019-11-12T05:58:56.000Z</published>
    <updated>2019-11-12T05:58:56.416Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>单源最短路径问题</title>
    <link href="http://yoursite.com/2019/11/12/%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2019/11/12/单源最短路径问题/</id>
    <published>2019-11-12T05:58:37.000Z</published>
    <updated>2019-11-12T05:58:37.936Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>最小生成树</title>
    <link href="http://yoursite.com/2019/11/12/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
    <id>http://yoursite.com/2019/11/12/最小生成树/</id>
    <published>2019-11-12T05:58:10.000Z</published>
    <updated>2019-11-12T05:58:10.413Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>优先队列</title>
    <link href="http://yoursite.com/2019/11/12/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"/>
    <id>http://yoursite.com/2019/11/12/优先队列/</id>
    <published>2019-11-12T05:57:53.000Z</published>
    <updated>2019-11-12T05:57:53.580Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>二叉搜索树</title>
    <link href="http://yoursite.com/2019/11/12/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    <id>http://yoursite.com/2019/11/12/二叉搜索树/</id>
    <published>2019-11-12T05:57:40.000Z</published>
    <updated>2019-11-12T05:57:40.049Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>DFS+BFS</title>
    <link href="http://yoursite.com/2019/11/12/DFS-BFS/"/>
    <id>http://yoursite.com/2019/11/12/DFS-BFS/</id>
    <published>2019-11-12T05:57:00.000Z</published>
    <updated>2019-11-12T05:57:00.527Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
</feed>
